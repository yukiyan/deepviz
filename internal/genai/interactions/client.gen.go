// Package interactions provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package interactions

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

// Defines values for CodeExecutionCallArgumentsLanguage.
const (
	Python CodeExecutionCallArgumentsLanguage = "python"
)

// Defines values for ComputerUseEnvironment.
const (
	Browser ComputerUseEnvironment = "browser"
)

// Defines values for CreateAgentInteractionParamsStatus.
const (
	CreateAgentInteractionParamsStatusCANCELLED      CreateAgentInteractionParamsStatus = "CANCELLED"
	CreateAgentInteractionParamsStatusCOMPLETED      CreateAgentInteractionParamsStatus = "COMPLETED"
	CreateAgentInteractionParamsStatusFAILED         CreateAgentInteractionParamsStatus = "FAILED"
	CreateAgentInteractionParamsStatusINPROGRESS     CreateAgentInteractionParamsStatus = "IN_PROGRESS"
	CreateAgentInteractionParamsStatusREQUIRESACTION CreateAgentInteractionParamsStatus = "REQUIRES_ACTION"
	CreateAgentInteractionParamsStatusUNSPECIFIED    CreateAgentInteractionParamsStatus = "UNSPECIFIED"
)

// Defines values for CreateModelInteractionParamsStatus.
const (
	CreateModelInteractionParamsStatusCANCELLED      CreateModelInteractionParamsStatus = "CANCELLED"
	CreateModelInteractionParamsStatusCOMPLETED      CreateModelInteractionParamsStatus = "COMPLETED"
	CreateModelInteractionParamsStatusFAILED         CreateModelInteractionParamsStatus = "FAILED"
	CreateModelInteractionParamsStatusINPROGRESS     CreateModelInteractionParamsStatus = "IN_PROGRESS"
	CreateModelInteractionParamsStatusREQUIRESACTION CreateModelInteractionParamsStatus = "REQUIRES_ACTION"
	CreateModelInteractionParamsStatusUNSPECIFIED    CreateModelInteractionParamsStatus = "UNSPECIFIED"
)

// Defines values for InteractionStatus.
const (
	Cancelled      InteractionStatus = "cancelled"
	Completed      InteractionStatus = "completed"
	Failed         InteractionStatus = "failed"
	InProgress     InteractionStatus = "in_progress"
	RequiresAction InteractionStatus = "requires_action"
)

// Defines values for MediaResolution.
const (
	MediaResolutionHigh      MediaResolution = "high"
	MediaResolutionLow       MediaResolution = "low"
	MediaResolutionMedium    MediaResolution = "medium"
	MediaResolutionUltraHigh MediaResolution = "ultra_high"
)

// Defines values for ResponseModality.
const (
	Audio ResponseModality = "audio"
	Image ResponseModality = "image"
	Text  ResponseModality = "text"
)

// Defines values for ThinkingLevel.
const (
	ThinkingLevelHigh    ThinkingLevel = "high"
	ThinkingLevelLow     ThinkingLevel = "low"
	ThinkingLevelMedium  ThinkingLevel = "medium"
	ThinkingLevelMinimal ThinkingLevel = "minimal"
)

// Defines values for ThinkingSummaries.
const (
	ThinkingSummariesAuto ThinkingSummaries = "auto"
	ThinkingSummariesNone ThinkingSummaries = "none"
)

// Defines values for ToolChoiceType.
const (
	ToolChoiceTypeAny       ToolChoiceType = "any"
	ToolChoiceTypeAuto      ToolChoiceType = "auto"
	ToolChoiceTypeNone      ToolChoiceType = "none"
	ToolChoiceTypeValidated ToolChoiceType = "validated"
)

// Defines values for UrlContextResultStatus.
const (
	UrlContextResultStatusError   UrlContextResultStatus = "error"
	UrlContextResultStatusPaywall UrlContextResultStatus = "paywall"
	UrlContextResultStatusSuccess UrlContextResultStatus = "success"
	UrlContextResultStatusUnsafe  UrlContextResultStatus = "unsafe"
)

// AgentOption The agent to interact with.
type AgentOption struct {
	union json.RawMessage
}

// AgentOption0 defines model for .
type AgentOption0 = string

// AgentOption1 Gemini Deep Research Agent
type AgentOption1 = interface{}

// AllowedTools The configuration for allowed tools.
type AllowedTools struct {
	Mode *ToolChoiceType `json:"mode,omitempty"`

	// Tools The names of the allowed tools.
	Tools *[]string `json:"tools,omitempty"`
}

// Annotation Citation information for model-generated content.
type Annotation struct {
	// EndIndex End of the attributed segment, exclusive.
	EndIndex *int32 `json:"end_index,omitempty"`

	// Source Source attributed for a portion of the text. Could be a URL, title, or
	// other identifier.
	Source *string `json:"source,omitempty"`

	// StartIndex Start of segment of the response that is attributed to this source.
	//
	// Index indicates the start of the segment, measured in bytes.
	StartIndex *int32 `json:"start_index,omitempty"`
}

// AudioContent An audio content block.
type AudioContent struct {
	Data *[]byte `json:"data,omitempty"`

	// MimeType The mime type of the audio.
	MimeType *AudioMimeTypeOption `json:"mime_type,omitempty"`
	Type     interface{}          `json:"type"`
	Uri      *string              `json:"uri,omitempty"`
}

// AudioMimeTypeOption The mime type of the audio.
type AudioMimeTypeOption struct {
	union json.RawMessage
}

// AudioMimeTypeOption0 defines model for .
type AudioMimeTypeOption0 = string

// AudioMimeTypeOption1 defines model for .
type AudioMimeTypeOption1 = interface{}

// AudioMimeTypeOption2 defines model for .
type AudioMimeTypeOption2 = interface{}

// AudioMimeTypeOption3 defines model for .
type AudioMimeTypeOption3 = interface{}

// AudioMimeTypeOption4 defines model for .
type AudioMimeTypeOption4 = interface{}

// AudioMimeTypeOption5 defines model for .
type AudioMimeTypeOption5 = interface{}

// AudioMimeTypeOption6 defines model for .
type AudioMimeTypeOption6 = interface{}

// CodeExecution A tool that can be used by the model to execute code.
type CodeExecution struct {
	Type string `json:"type"`
}

// CodeExecutionCallArguments The arguments to pass to the code execution.
type CodeExecutionCallArguments struct {
	// Code The code to be executed.
	Code *string `json:"code,omitempty"`

	// Language Programming language of the `code`.
	Language *CodeExecutionCallArgumentsLanguage `json:"language,omitempty"`
}

// CodeExecutionCallArgumentsLanguage Programming language of the `code`.
type CodeExecutionCallArgumentsLanguage string

// CodeExecutionCallContent Code execution content.
type CodeExecutionCallContent struct {
	// Arguments The arguments to pass to the code execution.
	Arguments *CodeExecutionCallArguments `json:"arguments,omitempty"`

	// Id A unique ID for this specific tool call.
	Id   *string     `json:"id,omitempty"`
	Type interface{} `json:"type"`
}

// CodeExecutionResultContent Code execution result content.
type CodeExecutionResultContent struct {
	// CallId ID to match the ID from the code execution call block.
	CallId *string `json:"call_id,omitempty"`

	// IsError Whether the code execution resulted in an error.
	IsError *bool `json:"is_error,omitempty"`

	// Result The output of the code execution.
	Result *string `json:"result,omitempty"`

	// Signature A signature hash for backend validation.
	Signature *string     `json:"signature,omitempty"`
	Type      interface{} `json:"type"`
}

// ComputerUse A tool that can be used by the model to interact with the computer.
type ComputerUse struct {
	// Environment The environment being operated.
	Environment *ComputerUseEnvironment `json:"environment,omitempty"`

	// ExcludedPredefinedFunctions The list of predefined functions that are excluded from the model call.
	ExcludedPredefinedFunctions *[]string `json:"excludedPredefinedFunctions,omitempty"`
	Type                        string    `json:"type"`
}

// ComputerUseEnvironment The environment being operated.
type ComputerUseEnvironment string

// Content The content of the response.
type Content struct {
	union json.RawMessage
}

// CreateAgentInteractionParams Parameters for creating agent interactions
type CreateAgentInteractionParams struct {
	// Agent The agent to interact with.
	Agent AgentOption `json:"agent"`

	// AgentConfig Configuration for the agent.
	AgentConfig *CreateAgentInteractionParams_AgentConfig `json:"agent_config,omitempty"`

	// Background Whether to run the model interaction in the background.
	Background *bool `json:"background,omitempty"`

	// Created Output only. The time at which the response was created in ISO 8601 format
	// (YYYY-MM-DDThh:mm:ssZ).
	Created *time.Time `json:"created,omitempty"`

	// Id Output only. A unique identifier for the interaction completion.
	Id *string `json:"id,omitempty"`

	// Input The inputs for the interaction.
	Input *CreateAgentInteractionParams_Input `json:"input,omitempty"`

	// Outputs Output only. Responses from the model.
	Outputs *[]Content `json:"outputs,omitempty"`

	// PreviousInteractionId The ID of the previous interaction, if any.
	PreviousInteractionId *string `json:"previous_interaction_id,omitempty"`

	// ResponseFormat Enforces that the generated response is a JSON object that complies with
	// the JSON schema specified in this field.
	ResponseFormat interface{} `json:"response_format,omitempty"`

	// ResponseMimeType The mime type of the response. This is required if response_format is set.
	ResponseMimeType *string `json:"response_mime_type,omitempty"`

	// ResponseModalities The requested modalities of the response (TEXT, IMAGE, AUDIO).
	ResponseModalities *[]ResponseModality `json:"response_modalities,omitempty"`

	// Role Output only. The role of the interaction.
	Role *string `json:"role,omitempty"`

	// Status Output only. The status of the interaction.
	Status *CreateAgentInteractionParamsStatus `json:"status,omitempty"`

	// Store Input only. Whether to store the response and request for later retrieval.
	Store *bool `json:"store,omitempty"`

	// Stream Input only. Whether the interaction will be streamed.
	Stream *bool `json:"stream,omitempty"`

	// SystemInstruction System instruction for the interaction.
	SystemInstruction *string `json:"system_instruction,omitempty"`

	// Tools A list of tool declarations the model may call during interaction.
	Tools *[]Tool `json:"tools,omitempty"`

	// Updated Output only. The time at which the response was last updated in ISO 8601 format
	// (YYYY-MM-DDThh:mm:ssZ).
	Updated *time.Time `json:"updated,omitempty"`

	// Usage Statistics on the interaction request's token usage.
	Usage *Usage `json:"usage,omitempty"`
}

// CreateAgentInteractionParams_AgentConfig Configuration for the agent.
type CreateAgentInteractionParams_AgentConfig struct {
	union json.RawMessage
}

// CreateAgentInteractionParamsInput0 defines model for .
type CreateAgentInteractionParamsInput0 = string

// CreateAgentInteractionParamsInput1 defines model for .
type CreateAgentInteractionParamsInput1 = []Content

// CreateAgentInteractionParamsInput2 defines model for .
type CreateAgentInteractionParamsInput2 = []Turn

// CreateAgentInteractionParams_Input The inputs for the interaction.
type CreateAgentInteractionParams_Input struct {
	union json.RawMessage
}

// CreateAgentInteractionParamsStatus Output only. The status of the interaction.
type CreateAgentInteractionParamsStatus string

// CreateModelInteractionParams Parameters for creating model interactions
type CreateModelInteractionParams struct {
	// Background Whether to run the model interaction in the background.
	Background *bool `json:"background,omitempty"`

	// Created Output only. The time at which the response was created in ISO 8601 format
	// (YYYY-MM-DDThh:mm:ssZ).
	Created *time.Time `json:"created,omitempty"`

	// GenerationConfig Configuration parameters for model interactions.
	GenerationConfig *GenerationConfig `json:"generation_config,omitempty"`

	// Id Output only. A unique identifier for the interaction completion.
	Id *string `json:"id,omitempty"`

	// Input The inputs for the interaction.
	Input *CreateModelInteractionParams_Input `json:"input,omitempty"`

	// Model The model that will complete your prompt.\n\nSee [models](https://ai.google.dev/gemini-api/docs/models) for additional details.
	Model ModelOption `json:"model"`

	// Outputs Output only. Responses from the model.
	Outputs *[]Content `json:"outputs,omitempty"`

	// PreviousInteractionId The ID of the previous interaction, if any.
	PreviousInteractionId *string `json:"previous_interaction_id,omitempty"`

	// ResponseFormat Enforces that the generated response is a JSON object that complies with
	// the JSON schema specified in this field.
	ResponseFormat interface{} `json:"response_format,omitempty"`

	// ResponseMimeType The mime type of the response. This is required if response_format is set.
	ResponseMimeType *string `json:"response_mime_type,omitempty"`

	// ResponseModalities The requested modalities of the response (TEXT, IMAGE, AUDIO).
	ResponseModalities *[]ResponseModality `json:"response_modalities,omitempty"`

	// Role Output only. The role of the interaction.
	Role *string `json:"role,omitempty"`

	// Status Output only. The status of the interaction.
	Status *CreateModelInteractionParamsStatus `json:"status,omitempty"`

	// Store Input only. Whether to store the response and request for later retrieval.
	Store *bool `json:"store,omitempty"`

	// Stream Input only. Whether the interaction will be streamed.
	Stream *bool `json:"stream,omitempty"`

	// SystemInstruction System instruction for the interaction.
	SystemInstruction *string `json:"system_instruction,omitempty"`

	// Tools A list of tool declarations the model may call during interaction.
	Tools *[]Tool `json:"tools,omitempty"`

	// Updated Output only. The time at which the response was last updated in ISO 8601 format
	// (YYYY-MM-DDThh:mm:ssZ).
	Updated *time.Time `json:"updated,omitempty"`

	// Usage Statistics on the interaction request's token usage.
	Usage *Usage `json:"usage,omitempty"`
}

// CreateModelInteractionParamsInput0 defines model for .
type CreateModelInteractionParamsInput0 = string

// CreateModelInteractionParamsInput1 defines model for .
type CreateModelInteractionParamsInput1 = []Content

// CreateModelInteractionParamsInput2 defines model for .
type CreateModelInteractionParamsInput2 = []Turn

// CreateModelInteractionParams_Input The inputs for the interaction.
type CreateModelInteractionParams_Input struct {
	union json.RawMessage
}

// CreateModelInteractionParamsStatus Output only. The status of the interaction.
type CreateModelInteractionParamsStatus string

// DeepResearchAgentConfig Configuration for the Deep Research agent.
type DeepResearchAgentConfig struct {
	ThinkingSummaries *ThinkingSummaries `json:"thinking_summaries,omitempty"`
	Type              interface{}        `json:"type,omitempty"`
}

// DocumentContent A document content block.
type DocumentContent struct {
	Data *[]byte `json:"data,omitempty"`

	// MimeType The mime type of the document.
	MimeType *DocumentMimeTypeOption `json:"mime_type,omitempty"`
	Type     interface{}             `json:"type"`
	Uri      *string                 `json:"uri,omitempty"`
}

// DocumentMimeTypeOption The mime type of the document.
type DocumentMimeTypeOption struct {
	union json.RawMessage
}

// DocumentMimeTypeOption0 defines model for .
type DocumentMimeTypeOption0 = string

// DocumentMimeTypeOption1 defines model for .
type DocumentMimeTypeOption1 = interface{}

// DynamicAgentConfig Configuration for dynamic agents.
type DynamicAgentConfig struct {
	Type                 interface{}            `json:"type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Error Error message from an interaction.
type Error struct {
	// Code A URI that identifies the error type.
	Code *string `json:"code,omitempty"`

	// Message A human-readable error message.
	Message *string `json:"message,omitempty"`
}

// FileSearch A tool that can be used by the model to search files.
type FileSearch struct {
	// FileSearchStoreNames The file search store names to search.
	FileSearchStoreNames *[]string `json:"file_search_store_names,omitempty"`

	// MetadataFilter Metadata filter to apply to the semantic retrieval documents and chunks.
	MetadataFilter *string `json:"metadata_filter,omitempty"`

	// TopK The number of semantic retrieval chunks to retrieve.
	TopK *int32 `json:"top_k,omitempty"`
	Type string `json:"type"`
}

// FileSearchResult The result of the File Search.
type FileSearchResult struct {
	// FileSearchStore The name of the file search store.
	FileSearchStore *string `json:"file_search_store,omitempty"`

	// Text The text of the search result.
	Text *string `json:"text,omitempty"`

	// Title The title of the search result.
	Title *string `json:"title,omitempty"`
}

// FileSearchResultContent File Search result content.
type FileSearchResultContent struct {
	// Result The results of the File Search.
	Result *[]FileSearchResult `json:"result,omitempty"`
	Type   interface{}         `json:"type"`
}

// Function A tool that can be used by the model.
type Function struct {
	// Description A description of the function.
	Description *string `json:"description,omitempty"`

	// Name The name of the function.
	Name *string `json:"name,omitempty"`

	// Parameters The JSON Schema for the function's parameters.
	Parameters interface{} `json:"parameters,omitempty"`
	Type       string      `json:"type"`
}

// FunctionCallContent A function tool call content block.
type FunctionCallContent struct {
	// Arguments The arguments to pass to the function.
	Arguments map[string]interface{} `json:"arguments"`

	// Id A unique ID for this specific tool call.
	Id string `json:"id"`

	// Name The name of the tool to call.
	Name string      `json:"name"`
	Type interface{} `json:"type"`
}

// FunctionResultContent A function tool result content block.
type FunctionResultContent struct {
	// CallId ID to match the ID from the function call block.
	CallId string `json:"call_id"`

	// IsError Whether the tool call resulted in an error.
	IsError *bool `json:"is_error,omitempty"`

	// Name The name of the tool that was called.
	Name *string `json:"name,omitempty"`

	// Result The result of the tool call.
	Result FunctionResultContent_Result `json:"result"`
	Type   interface{}                  `json:"type"`
}

// FunctionResultContentResult0 defines model for .
type FunctionResultContentResult0 struct {
	Items *[]FunctionResultContent_Result_0_Items_Item `json:"items,omitempty"`
}

// FunctionResultContentResult0Items0 defines model for .
type FunctionResultContentResult0Items0 = string

// FunctionResultContentResult0Items2 defines model for .
type FunctionResultContentResult0Items2 = map[string]interface{}

// FunctionResultContent_Result_0_Items_Item defines model for FunctionResultContent.result.0.items.Item.
type FunctionResultContent_Result_0_Items_Item struct {
	union json.RawMessage
}

// FunctionResultContentResult1 defines model for .
type FunctionResultContentResult1 = map[string]interface{}

// FunctionResultContentResult2 defines model for .
type FunctionResultContentResult2 = string

// FunctionResultContent_Result The result of the tool call.
type FunctionResultContent_Result struct {
	union json.RawMessage
}

// GenerationConfig Configuration parameters for model interactions.
type GenerationConfig struct {
	// MaxOutputTokens The maximum number of tokens to include in the response.
	MaxOutputTokens *int32 `json:"max_output_tokens,omitempty"`

	// Seed Seed used in decoding for reproducibility.
	Seed *int32 `json:"seed,omitempty"`

	// SpeechConfig Configuration for speech interaction.
	SpeechConfig *[]SpeechConfig `json:"speech_config,omitempty"`

	// StopSequences A list of character sequences that will stop output interaction.
	StopSequences *[]string `json:"stop_sequences,omitempty"`

	// Temperature Controls the randomness of the output.
	Temperature       *float32           `json:"temperature,omitempty"`
	ThinkingLevel     *ThinkingLevel     `json:"thinking_level,omitempty"`
	ThinkingSummaries *ThinkingSummaries `json:"thinking_summaries,omitempty"`

	// ToolChoice The configuration for tool choice.
	ToolChoice *ToolChoice `json:"tool_choice,omitempty"`

	// TopP The maximum cumulative probability of tokens to consider when sampling.
	TopP *float32 `json:"top_p,omitempty"`
}

// GoogleSearch A tool that can be used by the model to search Google.
type GoogleSearch struct {
	Type string `json:"type"`
}

// GoogleSearchCallArguments The arguments to pass to Google Search.
type GoogleSearchCallArguments struct {
	// Queries Web search queries for the following-up web search.
	Queries *[]string `json:"queries,omitempty"`
}

// GoogleSearchCallContent Google Search content.
type GoogleSearchCallContent struct {
	// Arguments The arguments to pass to Google Search.
	Arguments *GoogleSearchCallArguments `json:"arguments,omitempty"`

	// Id A unique ID for this specific tool call.
	Id   *string     `json:"id,omitempty"`
	Type interface{} `json:"type"`
}

// GoogleSearchResult The result of the Google Search.
type GoogleSearchResult struct {
	// RenderedContent Web content snippet that can be embedded in a web page or an app webview.
	RenderedContent *string `json:"rendered_content,omitempty"`

	// Title Title of the search result.
	Title *string `json:"title,omitempty"`

	// Url URI reference of the search result.
	Url *string `json:"url,omitempty"`
}

// GoogleSearchResultContent Google Search result content.
type GoogleSearchResultContent struct {
	// CallId ID to match the ID from the google search call block.
	CallId *string `json:"call_id,omitempty"`

	// IsError Whether the Google Search resulted in an error.
	IsError *bool `json:"is_error,omitempty"`

	// Result The results of the Google Search.
	Result *[]GoogleSearchResult `json:"result,omitempty"`

	// Signature The signature of the Google Search result.
	Signature *string     `json:"signature,omitempty"`
	Type      interface{} `json:"type"`
}

// ImageContent An image content block.
type ImageContent struct {
	Data *[]byte `json:"data,omitempty"`

	// MimeType The mime type of the image.
	MimeType   *ImageMimeTypeOption `json:"mime_type,omitempty"`
	Resolution *MediaResolution     `json:"resolution,omitempty"`
	Type       interface{}          `json:"type"`
	Uri        *string              `json:"uri,omitempty"`
}

// ImageMimeTypeOption The mime type of the image.
type ImageMimeTypeOption struct {
	union json.RawMessage
}

// ImageMimeTypeOption0 defines model for .
type ImageMimeTypeOption0 = string

// ImageMimeTypeOption1 defines model for .
type ImageMimeTypeOption1 = interface{}

// ImageMimeTypeOption2 defines model for .
type ImageMimeTypeOption2 = interface{}

// ImageMimeTypeOption3 defines model for .
type ImageMimeTypeOption3 = interface{}

// ImageMimeTypeOption4 defines model for .
type ImageMimeTypeOption4 = interface{}

// ImageMimeTypeOption5 defines model for .
type ImageMimeTypeOption5 = interface{}

// Interaction The Interaction resource.
type Interaction struct {
	// Agent The agent to interact with.
	Agent *AgentOption `json:"agent,omitempty"`

	// AgentConfig Configuration for the agent.
	AgentConfig *Interaction_AgentConfig `json:"agent_config,omitempty"`

	// Background Whether to run the model interaction in the background.
	Background *bool `json:"background,omitempty"`

	// Created Output only. The time at which the response was created in ISO 8601 format
	// (YYYY-MM-DDThh:mm:ssZ).
	Created *time.Time `json:"created,omitempty"`

	// GenerationConfig Configuration parameters for model interactions.
	GenerationConfig *GenerationConfig `json:"generation_config,omitempty"`

	// Id Output only. A unique identifier for the interaction completion.
	Id *string `json:"id,omitempty"`

	// Input The inputs for the interaction.
	Input *Interaction_Input `json:"input,omitempty"`

	// Model The model that will complete your prompt.\n\nSee [models](https://ai.google.dev/gemini-api/docs/models) for additional details.
	Model *ModelOption `json:"model,omitempty"`

	// Object Output only. The object type of the interaction. Always set to `interaction`.
	Object *string `json:"object,omitempty"`

	// Outputs Output only. Responses from the model.
	Outputs *[]Content `json:"outputs,omitempty"`

	// PreviousInteractionId The ID of the previous interaction, if any.
	PreviousInteractionId *string `json:"previous_interaction_id,omitempty"`

	// ResponseFormat Enforces that the generated response is a JSON object that complies with
	// the JSON schema specified in this field.
	ResponseFormat interface{} `json:"response_format,omitempty"`

	// ResponseMimeType The mime type of the response. This is required if response_format is set.
	ResponseMimeType *string `json:"response_mime_type,omitempty"`

	// ResponseModalities The requested modalities of the response (TEXT, IMAGE, AUDIO).
	ResponseModalities *[]ResponseModality `json:"response_modalities,omitempty"`

	// Role Output only. The role of the interaction.
	Role *string `json:"role,omitempty"`

	// Status Output only. The status of the interaction.
	Status *InteractionStatus `json:"status,omitempty"`

	// SystemInstruction System instruction for the interaction.
	SystemInstruction *string `json:"system_instruction,omitempty"`

	// Tools A list of tool declarations the model may call during interaction.
	Tools *[]Tool `json:"tools,omitempty"`

	// Updated Output only. The time at which the response was last updated in ISO 8601 format
	// (YYYY-MM-DDThh:mm:ssZ).
	Updated *time.Time `json:"updated,omitempty"`

	// Usage Statistics on the interaction request's token usage.
	Usage *Usage `json:"usage,omitempty"`
}

// Interaction_AgentConfig Configuration for the agent.
type Interaction_AgentConfig struct {
	union json.RawMessage
}

// InteractionInput0 defines model for .
type InteractionInput0 = string

// InteractionInput1 defines model for .
type InteractionInput1 = []Content

// InteractionInput2 defines model for .
type InteractionInput2 = []Turn

// Interaction_Input The inputs for the interaction.
type Interaction_Input struct {
	union json.RawMessage
}

// InteractionStatus Output only. The status of the interaction.
type InteractionStatus string

// McpServer A MCPServer is a server that can be called by the model to perform actions.
type McpServer struct {
	// AllowedTools The allowed tools.
	AllowedTools *[]AllowedTools `json:"allowed_tools,omitempty"`

	// Headers Optional: Fields for authentication headers, timeouts, etc., if needed.
	Headers *map[string]string `json:"headers,omitempty"`

	// Name The name of the MCPServer.
	Name *string `json:"name,omitempty"`
	Type string  `json:"type"`

	// Url The full URL for the MCPServer endpoint.
	// Example: "https://api.example.com/mcp"
	Url *string `json:"url,omitempty"`
}

// McpServerToolCallContent MCPServer tool call content.
type McpServerToolCallContent struct {
	// Arguments The JSON object of arguments for the function.
	Arguments map[string]interface{} `json:"arguments"`

	// Id A unique ID for this specific tool call.
	Id string `json:"id"`

	// Name The name of the tool which was called.
	Name string `json:"name"`

	// ServerName The name of the used MCP server.
	ServerName string      `json:"server_name"`
	Type       interface{} `json:"type"`
}

// McpServerToolResultContent MCPServer tool result content.
type McpServerToolResultContent struct {
	// CallId ID to match the ID from the MCP server tool call block.
	CallId string `json:"call_id"`

	// Name Name of the tool which is called for this specific tool call.
	Name *string `json:"name,omitempty"`

	// Result The result of the tool call.
	Result McpServerToolResultContent_Result `json:"result"`

	// ServerName The name of the used MCP server.
	ServerName *string     `json:"server_name,omitempty"`
	Type       interface{} `json:"type"`
}

// McpServerToolResultContentResult0 defines model for .
type McpServerToolResultContentResult0 struct {
	Items *[]McpServerToolResultContent_Result_0_Items_Item `json:"items,omitempty"`
}

// McpServerToolResultContentResult0Items0 defines model for .
type McpServerToolResultContentResult0Items0 = string

// McpServerToolResultContentResult0Items2 defines model for .
type McpServerToolResultContentResult0Items2 = map[string]interface{}

// McpServerToolResultContent_Result_0_Items_Item defines model for McpServerToolResultContent.result.0.items.Item.
type McpServerToolResultContent_Result_0_Items_Item struct {
	union json.RawMessage
}

// McpServerToolResultContentResult1 defines model for .
type McpServerToolResultContentResult1 = map[string]interface{}

// McpServerToolResultContentResult2 defines model for .
type McpServerToolResultContentResult2 = string

// McpServerToolResultContent_Result The result of the tool call.
type McpServerToolResultContent_Result struct {
	union json.RawMessage
}

// MediaResolution defines model for MediaResolution.
type MediaResolution string

// ModalityTokens The token count for a single response modality.
type ModalityTokens struct {
	Modality *ResponseModality `json:"modality,omitempty"`

	// Tokens Number of tokens for the modality.
	Tokens *int32 `json:"tokens,omitempty"`
}

// ModelOption The model that will complete your prompt.\n\nSee [models](https://ai.google.dev/gemini-api/docs/models) for additional details.
type ModelOption struct {
	union json.RawMessage
}

// ModelOption0 defines model for .
type ModelOption0 = string

// ModelOption1 Our state-of-the-art multipurpose model, which excels at coding and complex reasoning tasks.
type ModelOption1 = interface{}

// ModelOption2 Our first hybrid reasoning model which supports a 1M token context window and has thinking budgets.
type ModelOption2 = interface{}

// ModelOption3 The latest model based on the 2.5 Flash model. 2.5 Flash Preview is best for large scale processing, low-latency, high volume tasks that require thinking, and agentic use cases.
type ModelOption3 = interface{}

// ModelOption4 Our smallest and most cost effective model, built for at scale usage.
type ModelOption4 = interface{}

// ModelOption5 The latest model based on Gemini 2.5 Flash lite optimized for cost-efficiency, high throughput and high quality.
type ModelOption5 = interface{}

// ModelOption6 Our native audio models optimized for higher quality audio outputs with better pacing, voice naturalness, verbosity, and mood.
type ModelOption6 = interface{}

// ModelOption7 Our native image generation model, optimized for speed, flexibility, and contextual understanding. Text input and output is priced the same as 2.5 Flash.
type ModelOption7 = interface{}

// ModelOption8 Our 2.5 Pro text-to-speech audio model optimized for powerful, low-latency speech generation for more natural outputs and easier to steer prompts.
type ModelOption8 = interface{}

// ModelOption9 Our most intelligent model with SOTA reasoning and multimodal understanding, and powerful agentic and vibe coding capabilities.
type ModelOption9 = interface{}

// ModelOption10 Our most intelligent model built for speed, combining frontier intelligence with superior search and grounding.
type ModelOption10 = interface{}

// ResponseModality defines model for ResponseModality.
type ResponseModality string

// SpeechConfig The configuration for speech interaction.
type SpeechConfig struct {
	// Language The language of the speech.
	Language *string `json:"language,omitempty"`

	// Speaker The speaker's name, it should match the speaker name given in the prompt.
	Speaker *string `json:"speaker,omitempty"`

	// Voice The voice of the speaker.
	Voice *string `json:"voice,omitempty"`
}

// TextContent A text content block.
type TextContent struct {
	// Annotations Citation information for model-generated content.
	Annotations *[]Annotation `json:"annotations,omitempty"`

	// Text The text content.
	Text *string     `json:"text,omitempty"`
	Type interface{} `json:"type"`
}

// ThinkingLevel defines model for ThinkingLevel.
type ThinkingLevel string

// ThinkingSummaries defines model for ThinkingSummaries.
type ThinkingSummaries string

// ThoughtContent A thought content block.
type ThoughtContent struct {
	// Signature Signature to match the backend source to be part of the generation.
	Signature *[]byte `json:"signature,omitempty"`

	// Summary A summary of the thought.
	Summary *ThoughtSummary `json:"summary,omitempty"`
	Type    interface{}     `json:"type"`
}

// ThoughtSummary A summary of the thought.
type ThoughtSummary = []ThoughtSummary_Item

// ThoughtSummary_Item defines model for ThoughtSummary.Item.
type ThoughtSummary_Item struct {
	union json.RawMessage
}

// Tool defines model for Tool.
type Tool struct {
	union json.RawMessage
}

// ToolChoice The configuration for tool choice.
type ToolChoice struct {
	union json.RawMessage
}

// ToolChoiceConfig defines model for ToolChoiceConfig.
type ToolChoiceConfig struct {
	// AllowedTools The configuration for allowed tools.
	AllowedTools *AllowedTools `json:"allowed_tools,omitempty"`
}

// ToolChoiceType defines model for ToolChoiceType.
type ToolChoiceType string

// Turn defines model for Turn.
type Turn struct {
	// Content The content of the turn.
	Content *Turn_Content `json:"content,omitempty"`

	// Role The originator of this turn. Must be user for input or model for
	// model output.
	Role *string `json:"role,omitempty"`
}

// TurnContent0 defines model for .
type TurnContent0 = string

// TurnContent1 defines model for .
type TurnContent1 = []Content

// Turn_Content The content of the turn.
type Turn_Content struct {
	union json.RawMessage
}

// UrlContext A tool that can be used by the model to fetch URL context.
type UrlContext struct {
	Type string `json:"type"`
}

// UrlContextCallArguments The arguments to pass to the URL context.
type UrlContextCallArguments struct {
	// Urls The URLs to fetch.
	Urls *[]string `json:"urls,omitempty"`
}

// UrlContextCallContent URL context content.
type UrlContextCallContent struct {
	// Arguments The arguments to pass to the URL context.
	Arguments *UrlContextCallArguments `json:"arguments,omitempty"`

	// Id A unique ID for this specific tool call.
	Id   *string     `json:"id,omitempty"`
	Type interface{} `json:"type"`
}

// UrlContextResult The result of the URL context.
type UrlContextResult struct {
	// Status The status of the URL retrieval.
	Status *UrlContextResultStatus `json:"status,omitempty"`

	// Url The URL that was fetched.
	Url *string `json:"url,omitempty"`
}

// UrlContextResultStatus The status of the URL retrieval.
type UrlContextResultStatus string

// UrlContextResultContent URL context result content.
type UrlContextResultContent struct {
	// CallId ID to match the ID from the url context call block.
	CallId *string `json:"call_id,omitempty"`

	// IsError Whether the URL context resulted in an error.
	IsError *bool `json:"is_error,omitempty"`

	// Result The results of the URL context.
	Result *[]UrlContextResult `json:"result,omitempty"`

	// Signature The signature of the URL context result.
	Signature *string     `json:"signature,omitempty"`
	Type      interface{} `json:"type"`
}

// Usage Statistics on the interaction request's token usage.
type Usage struct {
	// CachedTokensByModality A breakdown of cached token usage by modality.
	CachedTokensByModality *[]ModalityTokens `json:"cached_tokens_by_modality,omitempty"`

	// InputTokensByModality A breakdown of input token usage by modality.
	InputTokensByModality *[]ModalityTokens `json:"input_tokens_by_modality,omitempty"`

	// OutputTokensByModality A breakdown of output token usage by modality.
	OutputTokensByModality *[]ModalityTokens `json:"output_tokens_by_modality,omitempty"`

	// ToolUseTokensByModality A breakdown of tool-use token usage by modality.
	ToolUseTokensByModality *[]ModalityTokens `json:"tool_use_tokens_by_modality,omitempty"`

	// TotalCachedTokens Number of tokens in the cached part of the prompt (the cached content).
	TotalCachedTokens *int32 `json:"total_cached_tokens,omitempty"`

	// TotalInputTokens Number of tokens in the prompt (context).
	TotalInputTokens *int32 `json:"total_input_tokens,omitempty"`

	// TotalOutputTokens Total number of tokens across all the generated responses.
	TotalOutputTokens *int32 `json:"total_output_tokens,omitempty"`

	// TotalReasoningTokens Number of tokens of thoughts for thinking models.
	TotalReasoningTokens *int32 `json:"total_reasoning_tokens,omitempty"`

	// TotalTokens Total token count for the interaction request (prompt + responses + other
	// internal tokens).
	TotalTokens *int32 `json:"total_tokens,omitempty"`

	// TotalToolUseTokens Number of tokens present in tool-use prompt(s).
	TotalToolUseTokens *int32 `json:"total_tool_use_tokens,omitempty"`
}

// VideoContent A video content block.
type VideoContent struct {
	Data *[]byte `json:"data,omitempty"`

	// MimeType The mime type of the video.
	MimeType   *VideoMimeTypeOption `json:"mime_type,omitempty"`
	Resolution *MediaResolution     `json:"resolution,omitempty"`
	Type       interface{}          `json:"type"`
	Uri        *string              `json:"uri,omitempty"`
}

// VideoMimeTypeOption The mime type of the video.
type VideoMimeTypeOption struct {
	union json.RawMessage
}

// VideoMimeTypeOption0 defines model for .
type VideoMimeTypeOption0 = string

// VideoMimeTypeOption1 defines model for .
type VideoMimeTypeOption1 = interface{}

// VideoMimeTypeOption2 defines model for .
type VideoMimeTypeOption2 = interface{}

// VideoMimeTypeOption3 defines model for .
type VideoMimeTypeOption3 = interface{}

// VideoMimeTypeOption4 defines model for .
type VideoMimeTypeOption4 = interface{}

// VideoMimeTypeOption5 defines model for .
type VideoMimeTypeOption5 = interface{}

// VideoMimeTypeOption6 defines model for .
type VideoMimeTypeOption6 = interface{}

// VideoMimeTypeOption7 defines model for .
type VideoMimeTypeOption7 = interface{}

// VideoMimeTypeOption8 defines model for .
type VideoMimeTypeOption8 = interface{}

// VideoMimeTypeOption9 defines model for .
type VideoMimeTypeOption9 = interface{}

// ApiVersion defines model for api_version.
type ApiVersion = string

// CreateInteractionJSONBody defines parameters for CreateInteraction.
type CreateInteractionJSONBody struct {
	union json.RawMessage
}

// GetInteractionByIdParams defines parameters for GetInteractionById.
type GetInteractionByIdParams struct {
	// Stream If set to true, the generated content will be streamed incrementally.
	Stream *bool `form:"stream,omitempty" json:"stream,omitempty"`

	// LastEventId Optional. If set, resumes the interaction stream from the next chunk after the event marked by the event id. Can only be used if `stream` is true.
	LastEventId *string `form:"last_event_id,omitempty" json:"last_event_id,omitempty"`
}

// CreateInteractionJSONRequestBody defines body for CreateInteraction for application/json ContentType.
type CreateInteractionJSONRequestBody CreateInteractionJSONBody

// Getter for additional properties for DynamicAgentConfig. Returns the specified
// element and whether it was found
func (a DynamicAgentConfig) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for DynamicAgentConfig
func (a *DynamicAgentConfig) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for DynamicAgentConfig to handle AdditionalProperties
func (a *DynamicAgentConfig) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for DynamicAgentConfig to handle AdditionalProperties
func (a DynamicAgentConfig) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsAgentOption0 returns the union data inside the AgentOption as a AgentOption0
func (t AgentOption) AsAgentOption0() (AgentOption0, error) {
	var body AgentOption0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentOption0 overwrites any union data inside the AgentOption as the provided AgentOption0
func (t *AgentOption) FromAgentOption0(v AgentOption0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentOption0 performs a merge with any union data inside the AgentOption, using the provided AgentOption0
func (t *AgentOption) MergeAgentOption0(v AgentOption0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAgentOption1 returns the union data inside the AgentOption as a AgentOption1
func (t AgentOption) AsAgentOption1() (AgentOption1, error) {
	var body AgentOption1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentOption1 overwrites any union data inside the AgentOption as the provided AgentOption1
func (t *AgentOption) FromAgentOption1(v AgentOption1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentOption1 performs a merge with any union data inside the AgentOption, using the provided AgentOption1
func (t *AgentOption) MergeAgentOption1(v AgentOption1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AgentOption) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AgentOption) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAudioMimeTypeOption0 returns the union data inside the AudioMimeTypeOption as a AudioMimeTypeOption0
func (t AudioMimeTypeOption) AsAudioMimeTypeOption0() (AudioMimeTypeOption0, error) {
	var body AudioMimeTypeOption0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAudioMimeTypeOption0 overwrites any union data inside the AudioMimeTypeOption as the provided AudioMimeTypeOption0
func (t *AudioMimeTypeOption) FromAudioMimeTypeOption0(v AudioMimeTypeOption0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAudioMimeTypeOption0 performs a merge with any union data inside the AudioMimeTypeOption, using the provided AudioMimeTypeOption0
func (t *AudioMimeTypeOption) MergeAudioMimeTypeOption0(v AudioMimeTypeOption0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAudioMimeTypeOption1 returns the union data inside the AudioMimeTypeOption as a AudioMimeTypeOption1
func (t AudioMimeTypeOption) AsAudioMimeTypeOption1() (AudioMimeTypeOption1, error) {
	var body AudioMimeTypeOption1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAudioMimeTypeOption1 overwrites any union data inside the AudioMimeTypeOption as the provided AudioMimeTypeOption1
func (t *AudioMimeTypeOption) FromAudioMimeTypeOption1(v AudioMimeTypeOption1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAudioMimeTypeOption1 performs a merge with any union data inside the AudioMimeTypeOption, using the provided AudioMimeTypeOption1
func (t *AudioMimeTypeOption) MergeAudioMimeTypeOption1(v AudioMimeTypeOption1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAudioMimeTypeOption2 returns the union data inside the AudioMimeTypeOption as a AudioMimeTypeOption2
func (t AudioMimeTypeOption) AsAudioMimeTypeOption2() (AudioMimeTypeOption2, error) {
	var body AudioMimeTypeOption2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAudioMimeTypeOption2 overwrites any union data inside the AudioMimeTypeOption as the provided AudioMimeTypeOption2
func (t *AudioMimeTypeOption) FromAudioMimeTypeOption2(v AudioMimeTypeOption2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAudioMimeTypeOption2 performs a merge with any union data inside the AudioMimeTypeOption, using the provided AudioMimeTypeOption2
func (t *AudioMimeTypeOption) MergeAudioMimeTypeOption2(v AudioMimeTypeOption2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAudioMimeTypeOption3 returns the union data inside the AudioMimeTypeOption as a AudioMimeTypeOption3
func (t AudioMimeTypeOption) AsAudioMimeTypeOption3() (AudioMimeTypeOption3, error) {
	var body AudioMimeTypeOption3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAudioMimeTypeOption3 overwrites any union data inside the AudioMimeTypeOption as the provided AudioMimeTypeOption3
func (t *AudioMimeTypeOption) FromAudioMimeTypeOption3(v AudioMimeTypeOption3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAudioMimeTypeOption3 performs a merge with any union data inside the AudioMimeTypeOption, using the provided AudioMimeTypeOption3
func (t *AudioMimeTypeOption) MergeAudioMimeTypeOption3(v AudioMimeTypeOption3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAudioMimeTypeOption4 returns the union data inside the AudioMimeTypeOption as a AudioMimeTypeOption4
func (t AudioMimeTypeOption) AsAudioMimeTypeOption4() (AudioMimeTypeOption4, error) {
	var body AudioMimeTypeOption4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAudioMimeTypeOption4 overwrites any union data inside the AudioMimeTypeOption as the provided AudioMimeTypeOption4
func (t *AudioMimeTypeOption) FromAudioMimeTypeOption4(v AudioMimeTypeOption4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAudioMimeTypeOption4 performs a merge with any union data inside the AudioMimeTypeOption, using the provided AudioMimeTypeOption4
func (t *AudioMimeTypeOption) MergeAudioMimeTypeOption4(v AudioMimeTypeOption4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAudioMimeTypeOption5 returns the union data inside the AudioMimeTypeOption as a AudioMimeTypeOption5
func (t AudioMimeTypeOption) AsAudioMimeTypeOption5() (AudioMimeTypeOption5, error) {
	var body AudioMimeTypeOption5
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAudioMimeTypeOption5 overwrites any union data inside the AudioMimeTypeOption as the provided AudioMimeTypeOption5
func (t *AudioMimeTypeOption) FromAudioMimeTypeOption5(v AudioMimeTypeOption5) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAudioMimeTypeOption5 performs a merge with any union data inside the AudioMimeTypeOption, using the provided AudioMimeTypeOption5
func (t *AudioMimeTypeOption) MergeAudioMimeTypeOption5(v AudioMimeTypeOption5) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAudioMimeTypeOption6 returns the union data inside the AudioMimeTypeOption as a AudioMimeTypeOption6
func (t AudioMimeTypeOption) AsAudioMimeTypeOption6() (AudioMimeTypeOption6, error) {
	var body AudioMimeTypeOption6
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAudioMimeTypeOption6 overwrites any union data inside the AudioMimeTypeOption as the provided AudioMimeTypeOption6
func (t *AudioMimeTypeOption) FromAudioMimeTypeOption6(v AudioMimeTypeOption6) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAudioMimeTypeOption6 performs a merge with any union data inside the AudioMimeTypeOption, using the provided AudioMimeTypeOption6
func (t *AudioMimeTypeOption) MergeAudioMimeTypeOption6(v AudioMimeTypeOption6) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AudioMimeTypeOption) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AudioMimeTypeOption) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTextContent returns the union data inside the Content as a TextContent
func (t Content) AsTextContent() (TextContent, error) {
	var body TextContent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTextContent overwrites any union data inside the Content as the provided TextContent
func (t *Content) FromTextContent(v TextContent) error {
	v.Type = "text"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTextContent performs a merge with any union data inside the Content, using the provided TextContent
func (t *Content) MergeTextContent(v TextContent) error {
	v.Type = "text"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImageContent returns the union data inside the Content as a ImageContent
func (t Content) AsImageContent() (ImageContent, error) {
	var body ImageContent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageContent overwrites any union data inside the Content as the provided ImageContent
func (t *Content) FromImageContent(v ImageContent) error {
	v.Type = "image"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageContent performs a merge with any union data inside the Content, using the provided ImageContent
func (t *Content) MergeImageContent(v ImageContent) error {
	v.Type = "image"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAudioContent returns the union data inside the Content as a AudioContent
func (t Content) AsAudioContent() (AudioContent, error) {
	var body AudioContent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAudioContent overwrites any union data inside the Content as the provided AudioContent
func (t *Content) FromAudioContent(v AudioContent) error {
	v.Type = "audio"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAudioContent performs a merge with any union data inside the Content, using the provided AudioContent
func (t *Content) MergeAudioContent(v AudioContent) error {
	v.Type = "audio"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDocumentContent returns the union data inside the Content as a DocumentContent
func (t Content) AsDocumentContent() (DocumentContent, error) {
	var body DocumentContent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDocumentContent overwrites any union data inside the Content as the provided DocumentContent
func (t *Content) FromDocumentContent(v DocumentContent) error {
	v.Type = "document"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDocumentContent performs a merge with any union data inside the Content, using the provided DocumentContent
func (t *Content) MergeDocumentContent(v DocumentContent) error {
	v.Type = "document"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVideoContent returns the union data inside the Content as a VideoContent
func (t Content) AsVideoContent() (VideoContent, error) {
	var body VideoContent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVideoContent overwrites any union data inside the Content as the provided VideoContent
func (t *Content) FromVideoContent(v VideoContent) error {
	v.Type = "video"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVideoContent performs a merge with any union data inside the Content, using the provided VideoContent
func (t *Content) MergeVideoContent(v VideoContent) error {
	v.Type = "video"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsThoughtContent returns the union data inside the Content as a ThoughtContent
func (t Content) AsThoughtContent() (ThoughtContent, error) {
	var body ThoughtContent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromThoughtContent overwrites any union data inside the Content as the provided ThoughtContent
func (t *Content) FromThoughtContent(v ThoughtContent) error {
	v.Type = "thought"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeThoughtContent performs a merge with any union data inside the Content, using the provided ThoughtContent
func (t *Content) MergeThoughtContent(v ThoughtContent) error {
	v.Type = "thought"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFunctionCallContent returns the union data inside the Content as a FunctionCallContent
func (t Content) AsFunctionCallContent() (FunctionCallContent, error) {
	var body FunctionCallContent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFunctionCallContent overwrites any union data inside the Content as the provided FunctionCallContent
func (t *Content) FromFunctionCallContent(v FunctionCallContent) error {
	v.Type = "function_call"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFunctionCallContent performs a merge with any union data inside the Content, using the provided FunctionCallContent
func (t *Content) MergeFunctionCallContent(v FunctionCallContent) error {
	v.Type = "function_call"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFunctionResultContent returns the union data inside the Content as a FunctionResultContent
func (t Content) AsFunctionResultContent() (FunctionResultContent, error) {
	var body FunctionResultContent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFunctionResultContent overwrites any union data inside the Content as the provided FunctionResultContent
func (t *Content) FromFunctionResultContent(v FunctionResultContent) error {
	v.Type = "function_result"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFunctionResultContent performs a merge with any union data inside the Content, using the provided FunctionResultContent
func (t *Content) MergeFunctionResultContent(v FunctionResultContent) error {
	v.Type = "function_result"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCodeExecutionCallContent returns the union data inside the Content as a CodeExecutionCallContent
func (t Content) AsCodeExecutionCallContent() (CodeExecutionCallContent, error) {
	var body CodeExecutionCallContent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCodeExecutionCallContent overwrites any union data inside the Content as the provided CodeExecutionCallContent
func (t *Content) FromCodeExecutionCallContent(v CodeExecutionCallContent) error {
	v.Type = "code_execution_call"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCodeExecutionCallContent performs a merge with any union data inside the Content, using the provided CodeExecutionCallContent
func (t *Content) MergeCodeExecutionCallContent(v CodeExecutionCallContent) error {
	v.Type = "code_execution_call"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCodeExecutionResultContent returns the union data inside the Content as a CodeExecutionResultContent
func (t Content) AsCodeExecutionResultContent() (CodeExecutionResultContent, error) {
	var body CodeExecutionResultContent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCodeExecutionResultContent overwrites any union data inside the Content as the provided CodeExecutionResultContent
func (t *Content) FromCodeExecutionResultContent(v CodeExecutionResultContent) error {
	v.Type = "code_execution_result"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCodeExecutionResultContent performs a merge with any union data inside the Content, using the provided CodeExecutionResultContent
func (t *Content) MergeCodeExecutionResultContent(v CodeExecutionResultContent) error {
	v.Type = "code_execution_result"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUrlContextCallContent returns the union data inside the Content as a UrlContextCallContent
func (t Content) AsUrlContextCallContent() (UrlContextCallContent, error) {
	var body UrlContextCallContent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUrlContextCallContent overwrites any union data inside the Content as the provided UrlContextCallContent
func (t *Content) FromUrlContextCallContent(v UrlContextCallContent) error {
	v.Type = "url_context_call"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUrlContextCallContent performs a merge with any union data inside the Content, using the provided UrlContextCallContent
func (t *Content) MergeUrlContextCallContent(v UrlContextCallContent) error {
	v.Type = "url_context_call"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUrlContextResultContent returns the union data inside the Content as a UrlContextResultContent
func (t Content) AsUrlContextResultContent() (UrlContextResultContent, error) {
	var body UrlContextResultContent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUrlContextResultContent overwrites any union data inside the Content as the provided UrlContextResultContent
func (t *Content) FromUrlContextResultContent(v UrlContextResultContent) error {
	v.Type = "url_context_result"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUrlContextResultContent performs a merge with any union data inside the Content, using the provided UrlContextResultContent
func (t *Content) MergeUrlContextResultContent(v UrlContextResultContent) error {
	v.Type = "url_context_result"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGoogleSearchCallContent returns the union data inside the Content as a GoogleSearchCallContent
func (t Content) AsGoogleSearchCallContent() (GoogleSearchCallContent, error) {
	var body GoogleSearchCallContent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGoogleSearchCallContent overwrites any union data inside the Content as the provided GoogleSearchCallContent
func (t *Content) FromGoogleSearchCallContent(v GoogleSearchCallContent) error {
	v.Type = "google_search_call"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGoogleSearchCallContent performs a merge with any union data inside the Content, using the provided GoogleSearchCallContent
func (t *Content) MergeGoogleSearchCallContent(v GoogleSearchCallContent) error {
	v.Type = "google_search_call"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGoogleSearchResultContent returns the union data inside the Content as a GoogleSearchResultContent
func (t Content) AsGoogleSearchResultContent() (GoogleSearchResultContent, error) {
	var body GoogleSearchResultContent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGoogleSearchResultContent overwrites any union data inside the Content as the provided GoogleSearchResultContent
func (t *Content) FromGoogleSearchResultContent(v GoogleSearchResultContent) error {
	v.Type = "google_search_result"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGoogleSearchResultContent performs a merge with any union data inside the Content, using the provided GoogleSearchResultContent
func (t *Content) MergeGoogleSearchResultContent(v GoogleSearchResultContent) error {
	v.Type = "google_search_result"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMcpServerToolCallContent returns the union data inside the Content as a McpServerToolCallContent
func (t Content) AsMcpServerToolCallContent() (McpServerToolCallContent, error) {
	var body McpServerToolCallContent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMcpServerToolCallContent overwrites any union data inside the Content as the provided McpServerToolCallContent
func (t *Content) FromMcpServerToolCallContent(v McpServerToolCallContent) error {
	v.Type = "mcp_server_tool_call"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMcpServerToolCallContent performs a merge with any union data inside the Content, using the provided McpServerToolCallContent
func (t *Content) MergeMcpServerToolCallContent(v McpServerToolCallContent) error {
	v.Type = "mcp_server_tool_call"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMcpServerToolResultContent returns the union data inside the Content as a McpServerToolResultContent
func (t Content) AsMcpServerToolResultContent() (McpServerToolResultContent, error) {
	var body McpServerToolResultContent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMcpServerToolResultContent overwrites any union data inside the Content as the provided McpServerToolResultContent
func (t *Content) FromMcpServerToolResultContent(v McpServerToolResultContent) error {
	v.Type = "mcp_server_tool_result"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMcpServerToolResultContent performs a merge with any union data inside the Content, using the provided McpServerToolResultContent
func (t *Content) MergeMcpServerToolResultContent(v McpServerToolResultContent) error {
	v.Type = "mcp_server_tool_result"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFileSearchResultContent returns the union data inside the Content as a FileSearchResultContent
func (t Content) AsFileSearchResultContent() (FileSearchResultContent, error) {
	var body FileSearchResultContent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFileSearchResultContent overwrites any union data inside the Content as the provided FileSearchResultContent
func (t *Content) FromFileSearchResultContent(v FileSearchResultContent) error {
	v.Type = "file_search_result"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFileSearchResultContent performs a merge with any union data inside the Content, using the provided FileSearchResultContent
func (t *Content) MergeFileSearchResultContent(v FileSearchResultContent) error {
	v.Type = "file_search_result"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Content) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Content) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "audio":
		return t.AsAudioContent()
	case "code_execution_call":
		return t.AsCodeExecutionCallContent()
	case "code_execution_result":
		return t.AsCodeExecutionResultContent()
	case "document":
		return t.AsDocumentContent()
	case "file_search_result":
		return t.AsFileSearchResultContent()
	case "function_call":
		return t.AsFunctionCallContent()
	case "function_result":
		return t.AsFunctionResultContent()
	case "google_search_call":
		return t.AsGoogleSearchCallContent()
	case "google_search_result":
		return t.AsGoogleSearchResultContent()
	case "image":
		return t.AsImageContent()
	case "mcp_server_tool_call":
		return t.AsMcpServerToolCallContent()
	case "mcp_server_tool_result":
		return t.AsMcpServerToolResultContent()
	case "text":
		return t.AsTextContent()
	case "thought":
		return t.AsThoughtContent()
	case "url_context_call":
		return t.AsUrlContextCallContent()
	case "url_context_result":
		return t.AsUrlContextResultContent()
	case "video":
		return t.AsVideoContent()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Content) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Content) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDynamicAgentConfig returns the union data inside the CreateAgentInteractionParams_AgentConfig as a DynamicAgentConfig
func (t CreateAgentInteractionParams_AgentConfig) AsDynamicAgentConfig() (DynamicAgentConfig, error) {
	var body DynamicAgentConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDynamicAgentConfig overwrites any union data inside the CreateAgentInteractionParams_AgentConfig as the provided DynamicAgentConfig
func (t *CreateAgentInteractionParams_AgentConfig) FromDynamicAgentConfig(v DynamicAgentConfig) error {
	v.Type = "dynamic"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDynamicAgentConfig performs a merge with any union data inside the CreateAgentInteractionParams_AgentConfig, using the provided DynamicAgentConfig
func (t *CreateAgentInteractionParams_AgentConfig) MergeDynamicAgentConfig(v DynamicAgentConfig) error {
	v.Type = "dynamic"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDeepResearchAgentConfig returns the union data inside the CreateAgentInteractionParams_AgentConfig as a DeepResearchAgentConfig
func (t CreateAgentInteractionParams_AgentConfig) AsDeepResearchAgentConfig() (DeepResearchAgentConfig, error) {
	var body DeepResearchAgentConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDeepResearchAgentConfig overwrites any union data inside the CreateAgentInteractionParams_AgentConfig as the provided DeepResearchAgentConfig
func (t *CreateAgentInteractionParams_AgentConfig) FromDeepResearchAgentConfig(v DeepResearchAgentConfig) error {
	v.Type = "deep_research"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDeepResearchAgentConfig performs a merge with any union data inside the CreateAgentInteractionParams_AgentConfig, using the provided DeepResearchAgentConfig
func (t *CreateAgentInteractionParams_AgentConfig) MergeDeepResearchAgentConfig(v DeepResearchAgentConfig) error {
	v.Type = "deep_research"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateAgentInteractionParams_AgentConfig) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t CreateAgentInteractionParams_AgentConfig) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "deep_research":
		return t.AsDeepResearchAgentConfig()
	case "dynamic":
		return t.AsDynamicAgentConfig()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t CreateAgentInteractionParams_AgentConfig) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateAgentInteractionParams_AgentConfig) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateAgentInteractionParamsInput0 returns the union data inside the CreateAgentInteractionParams_Input as a CreateAgentInteractionParamsInput0
func (t CreateAgentInteractionParams_Input) AsCreateAgentInteractionParamsInput0() (CreateAgentInteractionParamsInput0, error) {
	var body CreateAgentInteractionParamsInput0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateAgentInteractionParamsInput0 overwrites any union data inside the CreateAgentInteractionParams_Input as the provided CreateAgentInteractionParamsInput0
func (t *CreateAgentInteractionParams_Input) FromCreateAgentInteractionParamsInput0(v CreateAgentInteractionParamsInput0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateAgentInteractionParamsInput0 performs a merge with any union data inside the CreateAgentInteractionParams_Input, using the provided CreateAgentInteractionParamsInput0
func (t *CreateAgentInteractionParams_Input) MergeCreateAgentInteractionParamsInput0(v CreateAgentInteractionParamsInput0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateAgentInteractionParamsInput1 returns the union data inside the CreateAgentInteractionParams_Input as a CreateAgentInteractionParamsInput1
func (t CreateAgentInteractionParams_Input) AsCreateAgentInteractionParamsInput1() (CreateAgentInteractionParamsInput1, error) {
	var body CreateAgentInteractionParamsInput1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateAgentInteractionParamsInput1 overwrites any union data inside the CreateAgentInteractionParams_Input as the provided CreateAgentInteractionParamsInput1
func (t *CreateAgentInteractionParams_Input) FromCreateAgentInteractionParamsInput1(v CreateAgentInteractionParamsInput1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateAgentInteractionParamsInput1 performs a merge with any union data inside the CreateAgentInteractionParams_Input, using the provided CreateAgentInteractionParamsInput1
func (t *CreateAgentInteractionParams_Input) MergeCreateAgentInteractionParamsInput1(v CreateAgentInteractionParamsInput1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateAgentInteractionParamsInput2 returns the union data inside the CreateAgentInteractionParams_Input as a CreateAgentInteractionParamsInput2
func (t CreateAgentInteractionParams_Input) AsCreateAgentInteractionParamsInput2() (CreateAgentInteractionParamsInput2, error) {
	var body CreateAgentInteractionParamsInput2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateAgentInteractionParamsInput2 overwrites any union data inside the CreateAgentInteractionParams_Input as the provided CreateAgentInteractionParamsInput2
func (t *CreateAgentInteractionParams_Input) FromCreateAgentInteractionParamsInput2(v CreateAgentInteractionParamsInput2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateAgentInteractionParamsInput2 performs a merge with any union data inside the CreateAgentInteractionParams_Input, using the provided CreateAgentInteractionParamsInput2
func (t *CreateAgentInteractionParams_Input) MergeCreateAgentInteractionParamsInput2(v CreateAgentInteractionParamsInput2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContent returns the union data inside the CreateAgentInteractionParams_Input as a Content
func (t CreateAgentInteractionParams_Input) AsContent() (Content, error) {
	var body Content
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContent overwrites any union data inside the CreateAgentInteractionParams_Input as the provided Content
func (t *CreateAgentInteractionParams_Input) FromContent(v Content) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContent performs a merge with any union data inside the CreateAgentInteractionParams_Input, using the provided Content
func (t *CreateAgentInteractionParams_Input) MergeContent(v Content) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateAgentInteractionParams_Input) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateAgentInteractionParams_Input) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateModelInteractionParamsInput0 returns the union data inside the CreateModelInteractionParams_Input as a CreateModelInteractionParamsInput0
func (t CreateModelInteractionParams_Input) AsCreateModelInteractionParamsInput0() (CreateModelInteractionParamsInput0, error) {
	var body CreateModelInteractionParamsInput0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateModelInteractionParamsInput0 overwrites any union data inside the CreateModelInteractionParams_Input as the provided CreateModelInteractionParamsInput0
func (t *CreateModelInteractionParams_Input) FromCreateModelInteractionParamsInput0(v CreateModelInteractionParamsInput0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateModelInteractionParamsInput0 performs a merge with any union data inside the CreateModelInteractionParams_Input, using the provided CreateModelInteractionParamsInput0
func (t *CreateModelInteractionParams_Input) MergeCreateModelInteractionParamsInput0(v CreateModelInteractionParamsInput0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateModelInteractionParamsInput1 returns the union data inside the CreateModelInteractionParams_Input as a CreateModelInteractionParamsInput1
func (t CreateModelInteractionParams_Input) AsCreateModelInteractionParamsInput1() (CreateModelInteractionParamsInput1, error) {
	var body CreateModelInteractionParamsInput1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateModelInteractionParamsInput1 overwrites any union data inside the CreateModelInteractionParams_Input as the provided CreateModelInteractionParamsInput1
func (t *CreateModelInteractionParams_Input) FromCreateModelInteractionParamsInput1(v CreateModelInteractionParamsInput1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateModelInteractionParamsInput1 performs a merge with any union data inside the CreateModelInteractionParams_Input, using the provided CreateModelInteractionParamsInput1
func (t *CreateModelInteractionParams_Input) MergeCreateModelInteractionParamsInput1(v CreateModelInteractionParamsInput1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateModelInteractionParamsInput2 returns the union data inside the CreateModelInteractionParams_Input as a CreateModelInteractionParamsInput2
func (t CreateModelInteractionParams_Input) AsCreateModelInteractionParamsInput2() (CreateModelInteractionParamsInput2, error) {
	var body CreateModelInteractionParamsInput2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateModelInteractionParamsInput2 overwrites any union data inside the CreateModelInteractionParams_Input as the provided CreateModelInteractionParamsInput2
func (t *CreateModelInteractionParams_Input) FromCreateModelInteractionParamsInput2(v CreateModelInteractionParamsInput2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateModelInteractionParamsInput2 performs a merge with any union data inside the CreateModelInteractionParams_Input, using the provided CreateModelInteractionParamsInput2
func (t *CreateModelInteractionParams_Input) MergeCreateModelInteractionParamsInput2(v CreateModelInteractionParamsInput2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContent returns the union data inside the CreateModelInteractionParams_Input as a Content
func (t CreateModelInteractionParams_Input) AsContent() (Content, error) {
	var body Content
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContent overwrites any union data inside the CreateModelInteractionParams_Input as the provided Content
func (t *CreateModelInteractionParams_Input) FromContent(v Content) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContent performs a merge with any union data inside the CreateModelInteractionParams_Input, using the provided Content
func (t *CreateModelInteractionParams_Input) MergeContent(v Content) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateModelInteractionParams_Input) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateModelInteractionParams_Input) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDocumentMimeTypeOption0 returns the union data inside the DocumentMimeTypeOption as a DocumentMimeTypeOption0
func (t DocumentMimeTypeOption) AsDocumentMimeTypeOption0() (DocumentMimeTypeOption0, error) {
	var body DocumentMimeTypeOption0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDocumentMimeTypeOption0 overwrites any union data inside the DocumentMimeTypeOption as the provided DocumentMimeTypeOption0
func (t *DocumentMimeTypeOption) FromDocumentMimeTypeOption0(v DocumentMimeTypeOption0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDocumentMimeTypeOption0 performs a merge with any union data inside the DocumentMimeTypeOption, using the provided DocumentMimeTypeOption0
func (t *DocumentMimeTypeOption) MergeDocumentMimeTypeOption0(v DocumentMimeTypeOption0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDocumentMimeTypeOption1 returns the union data inside the DocumentMimeTypeOption as a DocumentMimeTypeOption1
func (t DocumentMimeTypeOption) AsDocumentMimeTypeOption1() (DocumentMimeTypeOption1, error) {
	var body DocumentMimeTypeOption1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDocumentMimeTypeOption1 overwrites any union data inside the DocumentMimeTypeOption as the provided DocumentMimeTypeOption1
func (t *DocumentMimeTypeOption) FromDocumentMimeTypeOption1(v DocumentMimeTypeOption1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDocumentMimeTypeOption1 performs a merge with any union data inside the DocumentMimeTypeOption, using the provided DocumentMimeTypeOption1
func (t *DocumentMimeTypeOption) MergeDocumentMimeTypeOption1(v DocumentMimeTypeOption1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DocumentMimeTypeOption) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DocumentMimeTypeOption) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFunctionResultContentResult0Items0 returns the union data inside the FunctionResultContent_Result_0_Items_Item as a FunctionResultContentResult0Items0
func (t FunctionResultContent_Result_0_Items_Item) AsFunctionResultContentResult0Items0() (FunctionResultContentResult0Items0, error) {
	var body FunctionResultContentResult0Items0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFunctionResultContentResult0Items0 overwrites any union data inside the FunctionResultContent_Result_0_Items_Item as the provided FunctionResultContentResult0Items0
func (t *FunctionResultContent_Result_0_Items_Item) FromFunctionResultContentResult0Items0(v FunctionResultContentResult0Items0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFunctionResultContentResult0Items0 performs a merge with any union data inside the FunctionResultContent_Result_0_Items_Item, using the provided FunctionResultContentResult0Items0
func (t *FunctionResultContent_Result_0_Items_Item) MergeFunctionResultContentResult0Items0(v FunctionResultContentResult0Items0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImageContent returns the union data inside the FunctionResultContent_Result_0_Items_Item as a ImageContent
func (t FunctionResultContent_Result_0_Items_Item) AsImageContent() (ImageContent, error) {
	var body ImageContent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageContent overwrites any union data inside the FunctionResultContent_Result_0_Items_Item as the provided ImageContent
func (t *FunctionResultContent_Result_0_Items_Item) FromImageContent(v ImageContent) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageContent performs a merge with any union data inside the FunctionResultContent_Result_0_Items_Item, using the provided ImageContent
func (t *FunctionResultContent_Result_0_Items_Item) MergeImageContent(v ImageContent) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFunctionResultContentResult0Items2 returns the union data inside the FunctionResultContent_Result_0_Items_Item as a FunctionResultContentResult0Items2
func (t FunctionResultContent_Result_0_Items_Item) AsFunctionResultContentResult0Items2() (FunctionResultContentResult0Items2, error) {
	var body FunctionResultContentResult0Items2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFunctionResultContentResult0Items2 overwrites any union data inside the FunctionResultContent_Result_0_Items_Item as the provided FunctionResultContentResult0Items2
func (t *FunctionResultContent_Result_0_Items_Item) FromFunctionResultContentResult0Items2(v FunctionResultContentResult0Items2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFunctionResultContentResult0Items2 performs a merge with any union data inside the FunctionResultContent_Result_0_Items_Item, using the provided FunctionResultContentResult0Items2
func (t *FunctionResultContent_Result_0_Items_Item) MergeFunctionResultContentResult0Items2(v FunctionResultContentResult0Items2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FunctionResultContent_Result_0_Items_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FunctionResultContent_Result_0_Items_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFunctionResultContentResult0 returns the union data inside the FunctionResultContent_Result as a FunctionResultContentResult0
func (t FunctionResultContent_Result) AsFunctionResultContentResult0() (FunctionResultContentResult0, error) {
	var body FunctionResultContentResult0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFunctionResultContentResult0 overwrites any union data inside the FunctionResultContent_Result as the provided FunctionResultContentResult0
func (t *FunctionResultContent_Result) FromFunctionResultContentResult0(v FunctionResultContentResult0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFunctionResultContentResult0 performs a merge with any union data inside the FunctionResultContent_Result, using the provided FunctionResultContentResult0
func (t *FunctionResultContent_Result) MergeFunctionResultContentResult0(v FunctionResultContentResult0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFunctionResultContentResult1 returns the union data inside the FunctionResultContent_Result as a FunctionResultContentResult1
func (t FunctionResultContent_Result) AsFunctionResultContentResult1() (FunctionResultContentResult1, error) {
	var body FunctionResultContentResult1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFunctionResultContentResult1 overwrites any union data inside the FunctionResultContent_Result as the provided FunctionResultContentResult1
func (t *FunctionResultContent_Result) FromFunctionResultContentResult1(v FunctionResultContentResult1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFunctionResultContentResult1 performs a merge with any union data inside the FunctionResultContent_Result, using the provided FunctionResultContentResult1
func (t *FunctionResultContent_Result) MergeFunctionResultContentResult1(v FunctionResultContentResult1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFunctionResultContentResult2 returns the union data inside the FunctionResultContent_Result as a FunctionResultContentResult2
func (t FunctionResultContent_Result) AsFunctionResultContentResult2() (FunctionResultContentResult2, error) {
	var body FunctionResultContentResult2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFunctionResultContentResult2 overwrites any union data inside the FunctionResultContent_Result as the provided FunctionResultContentResult2
func (t *FunctionResultContent_Result) FromFunctionResultContentResult2(v FunctionResultContentResult2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFunctionResultContentResult2 performs a merge with any union data inside the FunctionResultContent_Result, using the provided FunctionResultContentResult2
func (t *FunctionResultContent_Result) MergeFunctionResultContentResult2(v FunctionResultContentResult2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FunctionResultContent_Result) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FunctionResultContent_Result) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsImageMimeTypeOption0 returns the union data inside the ImageMimeTypeOption as a ImageMimeTypeOption0
func (t ImageMimeTypeOption) AsImageMimeTypeOption0() (ImageMimeTypeOption0, error) {
	var body ImageMimeTypeOption0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageMimeTypeOption0 overwrites any union data inside the ImageMimeTypeOption as the provided ImageMimeTypeOption0
func (t *ImageMimeTypeOption) FromImageMimeTypeOption0(v ImageMimeTypeOption0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageMimeTypeOption0 performs a merge with any union data inside the ImageMimeTypeOption, using the provided ImageMimeTypeOption0
func (t *ImageMimeTypeOption) MergeImageMimeTypeOption0(v ImageMimeTypeOption0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImageMimeTypeOption1 returns the union data inside the ImageMimeTypeOption as a ImageMimeTypeOption1
func (t ImageMimeTypeOption) AsImageMimeTypeOption1() (ImageMimeTypeOption1, error) {
	var body ImageMimeTypeOption1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageMimeTypeOption1 overwrites any union data inside the ImageMimeTypeOption as the provided ImageMimeTypeOption1
func (t *ImageMimeTypeOption) FromImageMimeTypeOption1(v ImageMimeTypeOption1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageMimeTypeOption1 performs a merge with any union data inside the ImageMimeTypeOption, using the provided ImageMimeTypeOption1
func (t *ImageMimeTypeOption) MergeImageMimeTypeOption1(v ImageMimeTypeOption1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImageMimeTypeOption2 returns the union data inside the ImageMimeTypeOption as a ImageMimeTypeOption2
func (t ImageMimeTypeOption) AsImageMimeTypeOption2() (ImageMimeTypeOption2, error) {
	var body ImageMimeTypeOption2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageMimeTypeOption2 overwrites any union data inside the ImageMimeTypeOption as the provided ImageMimeTypeOption2
func (t *ImageMimeTypeOption) FromImageMimeTypeOption2(v ImageMimeTypeOption2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageMimeTypeOption2 performs a merge with any union data inside the ImageMimeTypeOption, using the provided ImageMimeTypeOption2
func (t *ImageMimeTypeOption) MergeImageMimeTypeOption2(v ImageMimeTypeOption2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImageMimeTypeOption3 returns the union data inside the ImageMimeTypeOption as a ImageMimeTypeOption3
func (t ImageMimeTypeOption) AsImageMimeTypeOption3() (ImageMimeTypeOption3, error) {
	var body ImageMimeTypeOption3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageMimeTypeOption3 overwrites any union data inside the ImageMimeTypeOption as the provided ImageMimeTypeOption3
func (t *ImageMimeTypeOption) FromImageMimeTypeOption3(v ImageMimeTypeOption3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageMimeTypeOption3 performs a merge with any union data inside the ImageMimeTypeOption, using the provided ImageMimeTypeOption3
func (t *ImageMimeTypeOption) MergeImageMimeTypeOption3(v ImageMimeTypeOption3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImageMimeTypeOption4 returns the union data inside the ImageMimeTypeOption as a ImageMimeTypeOption4
func (t ImageMimeTypeOption) AsImageMimeTypeOption4() (ImageMimeTypeOption4, error) {
	var body ImageMimeTypeOption4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageMimeTypeOption4 overwrites any union data inside the ImageMimeTypeOption as the provided ImageMimeTypeOption4
func (t *ImageMimeTypeOption) FromImageMimeTypeOption4(v ImageMimeTypeOption4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageMimeTypeOption4 performs a merge with any union data inside the ImageMimeTypeOption, using the provided ImageMimeTypeOption4
func (t *ImageMimeTypeOption) MergeImageMimeTypeOption4(v ImageMimeTypeOption4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImageMimeTypeOption5 returns the union data inside the ImageMimeTypeOption as a ImageMimeTypeOption5
func (t ImageMimeTypeOption) AsImageMimeTypeOption5() (ImageMimeTypeOption5, error) {
	var body ImageMimeTypeOption5
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageMimeTypeOption5 overwrites any union data inside the ImageMimeTypeOption as the provided ImageMimeTypeOption5
func (t *ImageMimeTypeOption) FromImageMimeTypeOption5(v ImageMimeTypeOption5) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageMimeTypeOption5 performs a merge with any union data inside the ImageMimeTypeOption, using the provided ImageMimeTypeOption5
func (t *ImageMimeTypeOption) MergeImageMimeTypeOption5(v ImageMimeTypeOption5) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ImageMimeTypeOption) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ImageMimeTypeOption) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDynamicAgentConfig returns the union data inside the Interaction_AgentConfig as a DynamicAgentConfig
func (t Interaction_AgentConfig) AsDynamicAgentConfig() (DynamicAgentConfig, error) {
	var body DynamicAgentConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDynamicAgentConfig overwrites any union data inside the Interaction_AgentConfig as the provided DynamicAgentConfig
func (t *Interaction_AgentConfig) FromDynamicAgentConfig(v DynamicAgentConfig) error {
	v.Type = "dynamic"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDynamicAgentConfig performs a merge with any union data inside the Interaction_AgentConfig, using the provided DynamicAgentConfig
func (t *Interaction_AgentConfig) MergeDynamicAgentConfig(v DynamicAgentConfig) error {
	v.Type = "dynamic"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDeepResearchAgentConfig returns the union data inside the Interaction_AgentConfig as a DeepResearchAgentConfig
func (t Interaction_AgentConfig) AsDeepResearchAgentConfig() (DeepResearchAgentConfig, error) {
	var body DeepResearchAgentConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDeepResearchAgentConfig overwrites any union data inside the Interaction_AgentConfig as the provided DeepResearchAgentConfig
func (t *Interaction_AgentConfig) FromDeepResearchAgentConfig(v DeepResearchAgentConfig) error {
	v.Type = "deep_research"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDeepResearchAgentConfig performs a merge with any union data inside the Interaction_AgentConfig, using the provided DeepResearchAgentConfig
func (t *Interaction_AgentConfig) MergeDeepResearchAgentConfig(v DeepResearchAgentConfig) error {
	v.Type = "deep_research"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Interaction_AgentConfig) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Interaction_AgentConfig) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "deep_research":
		return t.AsDeepResearchAgentConfig()
	case "dynamic":
		return t.AsDynamicAgentConfig()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Interaction_AgentConfig) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Interaction_AgentConfig) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsInteractionInput0 returns the union data inside the Interaction_Input as a InteractionInput0
func (t Interaction_Input) AsInteractionInput0() (InteractionInput0, error) {
	var body InteractionInput0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInteractionInput0 overwrites any union data inside the Interaction_Input as the provided InteractionInput0
func (t *Interaction_Input) FromInteractionInput0(v InteractionInput0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInteractionInput0 performs a merge with any union data inside the Interaction_Input, using the provided InteractionInput0
func (t *Interaction_Input) MergeInteractionInput0(v InteractionInput0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInteractionInput1 returns the union data inside the Interaction_Input as a InteractionInput1
func (t Interaction_Input) AsInteractionInput1() (InteractionInput1, error) {
	var body InteractionInput1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInteractionInput1 overwrites any union data inside the Interaction_Input as the provided InteractionInput1
func (t *Interaction_Input) FromInteractionInput1(v InteractionInput1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInteractionInput1 performs a merge with any union data inside the Interaction_Input, using the provided InteractionInput1
func (t *Interaction_Input) MergeInteractionInput1(v InteractionInput1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInteractionInput2 returns the union data inside the Interaction_Input as a InteractionInput2
func (t Interaction_Input) AsInteractionInput2() (InteractionInput2, error) {
	var body InteractionInput2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInteractionInput2 overwrites any union data inside the Interaction_Input as the provided InteractionInput2
func (t *Interaction_Input) FromInteractionInput2(v InteractionInput2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInteractionInput2 performs a merge with any union data inside the Interaction_Input, using the provided InteractionInput2
func (t *Interaction_Input) MergeInteractionInput2(v InteractionInput2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContent returns the union data inside the Interaction_Input as a Content
func (t Interaction_Input) AsContent() (Content, error) {
	var body Content
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContent overwrites any union data inside the Interaction_Input as the provided Content
func (t *Interaction_Input) FromContent(v Content) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContent performs a merge with any union data inside the Interaction_Input, using the provided Content
func (t *Interaction_Input) MergeContent(v Content) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Interaction_Input) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Interaction_Input) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMcpServerToolResultContentResult0Items0 returns the union data inside the McpServerToolResultContent_Result_0_Items_Item as a McpServerToolResultContentResult0Items0
func (t McpServerToolResultContent_Result_0_Items_Item) AsMcpServerToolResultContentResult0Items0() (McpServerToolResultContentResult0Items0, error) {
	var body McpServerToolResultContentResult0Items0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMcpServerToolResultContentResult0Items0 overwrites any union data inside the McpServerToolResultContent_Result_0_Items_Item as the provided McpServerToolResultContentResult0Items0
func (t *McpServerToolResultContent_Result_0_Items_Item) FromMcpServerToolResultContentResult0Items0(v McpServerToolResultContentResult0Items0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMcpServerToolResultContentResult0Items0 performs a merge with any union data inside the McpServerToolResultContent_Result_0_Items_Item, using the provided McpServerToolResultContentResult0Items0
func (t *McpServerToolResultContent_Result_0_Items_Item) MergeMcpServerToolResultContentResult0Items0(v McpServerToolResultContentResult0Items0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImageContent returns the union data inside the McpServerToolResultContent_Result_0_Items_Item as a ImageContent
func (t McpServerToolResultContent_Result_0_Items_Item) AsImageContent() (ImageContent, error) {
	var body ImageContent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageContent overwrites any union data inside the McpServerToolResultContent_Result_0_Items_Item as the provided ImageContent
func (t *McpServerToolResultContent_Result_0_Items_Item) FromImageContent(v ImageContent) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageContent performs a merge with any union data inside the McpServerToolResultContent_Result_0_Items_Item, using the provided ImageContent
func (t *McpServerToolResultContent_Result_0_Items_Item) MergeImageContent(v ImageContent) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMcpServerToolResultContentResult0Items2 returns the union data inside the McpServerToolResultContent_Result_0_Items_Item as a McpServerToolResultContentResult0Items2
func (t McpServerToolResultContent_Result_0_Items_Item) AsMcpServerToolResultContentResult0Items2() (McpServerToolResultContentResult0Items2, error) {
	var body McpServerToolResultContentResult0Items2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMcpServerToolResultContentResult0Items2 overwrites any union data inside the McpServerToolResultContent_Result_0_Items_Item as the provided McpServerToolResultContentResult0Items2
func (t *McpServerToolResultContent_Result_0_Items_Item) FromMcpServerToolResultContentResult0Items2(v McpServerToolResultContentResult0Items2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMcpServerToolResultContentResult0Items2 performs a merge with any union data inside the McpServerToolResultContent_Result_0_Items_Item, using the provided McpServerToolResultContentResult0Items2
func (t *McpServerToolResultContent_Result_0_Items_Item) MergeMcpServerToolResultContentResult0Items2(v McpServerToolResultContentResult0Items2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t McpServerToolResultContent_Result_0_Items_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *McpServerToolResultContent_Result_0_Items_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMcpServerToolResultContentResult0 returns the union data inside the McpServerToolResultContent_Result as a McpServerToolResultContentResult0
func (t McpServerToolResultContent_Result) AsMcpServerToolResultContentResult0() (McpServerToolResultContentResult0, error) {
	var body McpServerToolResultContentResult0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMcpServerToolResultContentResult0 overwrites any union data inside the McpServerToolResultContent_Result as the provided McpServerToolResultContentResult0
func (t *McpServerToolResultContent_Result) FromMcpServerToolResultContentResult0(v McpServerToolResultContentResult0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMcpServerToolResultContentResult0 performs a merge with any union data inside the McpServerToolResultContent_Result, using the provided McpServerToolResultContentResult0
func (t *McpServerToolResultContent_Result) MergeMcpServerToolResultContentResult0(v McpServerToolResultContentResult0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMcpServerToolResultContentResult1 returns the union data inside the McpServerToolResultContent_Result as a McpServerToolResultContentResult1
func (t McpServerToolResultContent_Result) AsMcpServerToolResultContentResult1() (McpServerToolResultContentResult1, error) {
	var body McpServerToolResultContentResult1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMcpServerToolResultContentResult1 overwrites any union data inside the McpServerToolResultContent_Result as the provided McpServerToolResultContentResult1
func (t *McpServerToolResultContent_Result) FromMcpServerToolResultContentResult1(v McpServerToolResultContentResult1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMcpServerToolResultContentResult1 performs a merge with any union data inside the McpServerToolResultContent_Result, using the provided McpServerToolResultContentResult1
func (t *McpServerToolResultContent_Result) MergeMcpServerToolResultContentResult1(v McpServerToolResultContentResult1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMcpServerToolResultContentResult2 returns the union data inside the McpServerToolResultContent_Result as a McpServerToolResultContentResult2
func (t McpServerToolResultContent_Result) AsMcpServerToolResultContentResult2() (McpServerToolResultContentResult2, error) {
	var body McpServerToolResultContentResult2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMcpServerToolResultContentResult2 overwrites any union data inside the McpServerToolResultContent_Result as the provided McpServerToolResultContentResult2
func (t *McpServerToolResultContent_Result) FromMcpServerToolResultContentResult2(v McpServerToolResultContentResult2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMcpServerToolResultContentResult2 performs a merge with any union data inside the McpServerToolResultContent_Result, using the provided McpServerToolResultContentResult2
func (t *McpServerToolResultContent_Result) MergeMcpServerToolResultContentResult2(v McpServerToolResultContentResult2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t McpServerToolResultContent_Result) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *McpServerToolResultContent_Result) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsModelOption0 returns the union data inside the ModelOption as a ModelOption0
func (t ModelOption) AsModelOption0() (ModelOption0, error) {
	var body ModelOption0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelOption0 overwrites any union data inside the ModelOption as the provided ModelOption0
func (t *ModelOption) FromModelOption0(v ModelOption0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelOption0 performs a merge with any union data inside the ModelOption, using the provided ModelOption0
func (t *ModelOption) MergeModelOption0(v ModelOption0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModelOption1 returns the union data inside the ModelOption as a ModelOption1
func (t ModelOption) AsModelOption1() (ModelOption1, error) {
	var body ModelOption1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelOption1 overwrites any union data inside the ModelOption as the provided ModelOption1
func (t *ModelOption) FromModelOption1(v ModelOption1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelOption1 performs a merge with any union data inside the ModelOption, using the provided ModelOption1
func (t *ModelOption) MergeModelOption1(v ModelOption1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModelOption2 returns the union data inside the ModelOption as a ModelOption2
func (t ModelOption) AsModelOption2() (ModelOption2, error) {
	var body ModelOption2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelOption2 overwrites any union data inside the ModelOption as the provided ModelOption2
func (t *ModelOption) FromModelOption2(v ModelOption2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelOption2 performs a merge with any union data inside the ModelOption, using the provided ModelOption2
func (t *ModelOption) MergeModelOption2(v ModelOption2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModelOption3 returns the union data inside the ModelOption as a ModelOption3
func (t ModelOption) AsModelOption3() (ModelOption3, error) {
	var body ModelOption3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelOption3 overwrites any union data inside the ModelOption as the provided ModelOption3
func (t *ModelOption) FromModelOption3(v ModelOption3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelOption3 performs a merge with any union data inside the ModelOption, using the provided ModelOption3
func (t *ModelOption) MergeModelOption3(v ModelOption3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModelOption4 returns the union data inside the ModelOption as a ModelOption4
func (t ModelOption) AsModelOption4() (ModelOption4, error) {
	var body ModelOption4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelOption4 overwrites any union data inside the ModelOption as the provided ModelOption4
func (t *ModelOption) FromModelOption4(v ModelOption4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelOption4 performs a merge with any union data inside the ModelOption, using the provided ModelOption4
func (t *ModelOption) MergeModelOption4(v ModelOption4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModelOption5 returns the union data inside the ModelOption as a ModelOption5
func (t ModelOption) AsModelOption5() (ModelOption5, error) {
	var body ModelOption5
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelOption5 overwrites any union data inside the ModelOption as the provided ModelOption5
func (t *ModelOption) FromModelOption5(v ModelOption5) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelOption5 performs a merge with any union data inside the ModelOption, using the provided ModelOption5
func (t *ModelOption) MergeModelOption5(v ModelOption5) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModelOption6 returns the union data inside the ModelOption as a ModelOption6
func (t ModelOption) AsModelOption6() (ModelOption6, error) {
	var body ModelOption6
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelOption6 overwrites any union data inside the ModelOption as the provided ModelOption6
func (t *ModelOption) FromModelOption6(v ModelOption6) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelOption6 performs a merge with any union data inside the ModelOption, using the provided ModelOption6
func (t *ModelOption) MergeModelOption6(v ModelOption6) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModelOption7 returns the union data inside the ModelOption as a ModelOption7
func (t ModelOption) AsModelOption7() (ModelOption7, error) {
	var body ModelOption7
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelOption7 overwrites any union data inside the ModelOption as the provided ModelOption7
func (t *ModelOption) FromModelOption7(v ModelOption7) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelOption7 performs a merge with any union data inside the ModelOption, using the provided ModelOption7
func (t *ModelOption) MergeModelOption7(v ModelOption7) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModelOption8 returns the union data inside the ModelOption as a ModelOption8
func (t ModelOption) AsModelOption8() (ModelOption8, error) {
	var body ModelOption8
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelOption8 overwrites any union data inside the ModelOption as the provided ModelOption8
func (t *ModelOption) FromModelOption8(v ModelOption8) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelOption8 performs a merge with any union data inside the ModelOption, using the provided ModelOption8
func (t *ModelOption) MergeModelOption8(v ModelOption8) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModelOption9 returns the union data inside the ModelOption as a ModelOption9
func (t ModelOption) AsModelOption9() (ModelOption9, error) {
	var body ModelOption9
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelOption9 overwrites any union data inside the ModelOption as the provided ModelOption9
func (t *ModelOption) FromModelOption9(v ModelOption9) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelOption9 performs a merge with any union data inside the ModelOption, using the provided ModelOption9
func (t *ModelOption) MergeModelOption9(v ModelOption9) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModelOption10 returns the union data inside the ModelOption as a ModelOption10
func (t ModelOption) AsModelOption10() (ModelOption10, error) {
	var body ModelOption10
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModelOption10 overwrites any union data inside the ModelOption as the provided ModelOption10
func (t *ModelOption) FromModelOption10(v ModelOption10) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModelOption10 performs a merge with any union data inside the ModelOption, using the provided ModelOption10
func (t *ModelOption) MergeModelOption10(v ModelOption10) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ModelOption) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ModelOption) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTextContent returns the union data inside the ThoughtSummary_Item as a TextContent
func (t ThoughtSummary_Item) AsTextContent() (TextContent, error) {
	var body TextContent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTextContent overwrites any union data inside the ThoughtSummary_Item as the provided TextContent
func (t *ThoughtSummary_Item) FromTextContent(v TextContent) error {
	v.Type = "text"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTextContent performs a merge with any union data inside the ThoughtSummary_Item, using the provided TextContent
func (t *ThoughtSummary_Item) MergeTextContent(v TextContent) error {
	v.Type = "text"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImageContent returns the union data inside the ThoughtSummary_Item as a ImageContent
func (t ThoughtSummary_Item) AsImageContent() (ImageContent, error) {
	var body ImageContent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageContent overwrites any union data inside the ThoughtSummary_Item as the provided ImageContent
func (t *ThoughtSummary_Item) FromImageContent(v ImageContent) error {
	v.Type = "image"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageContent performs a merge with any union data inside the ThoughtSummary_Item, using the provided ImageContent
func (t *ThoughtSummary_Item) MergeImageContent(v ImageContent) error {
	v.Type = "image"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ThoughtSummary_Item) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ThoughtSummary_Item) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "image":
		return t.AsImageContent()
	case "text":
		return t.AsTextContent()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ThoughtSummary_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ThoughtSummary_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFunction returns the union data inside the Tool as a Function
func (t Tool) AsFunction() (Function, error) {
	var body Function
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFunction overwrites any union data inside the Tool as the provided Function
func (t *Tool) FromFunction(v Function) error {
	v.Type = "function"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFunction performs a merge with any union data inside the Tool, using the provided Function
func (t *Tool) MergeFunction(v Function) error {
	v.Type = "function"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGoogleSearch returns the union data inside the Tool as a GoogleSearch
func (t Tool) AsGoogleSearch() (GoogleSearch, error) {
	var body GoogleSearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGoogleSearch overwrites any union data inside the Tool as the provided GoogleSearch
func (t *Tool) FromGoogleSearch(v GoogleSearch) error {
	v.Type = "google_search"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGoogleSearch performs a merge with any union data inside the Tool, using the provided GoogleSearch
func (t *Tool) MergeGoogleSearch(v GoogleSearch) error {
	v.Type = "google_search"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCodeExecution returns the union data inside the Tool as a CodeExecution
func (t Tool) AsCodeExecution() (CodeExecution, error) {
	var body CodeExecution
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCodeExecution overwrites any union data inside the Tool as the provided CodeExecution
func (t *Tool) FromCodeExecution(v CodeExecution) error {
	v.Type = "code_execution"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCodeExecution performs a merge with any union data inside the Tool, using the provided CodeExecution
func (t *Tool) MergeCodeExecution(v CodeExecution) error {
	v.Type = "code_execution"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUrlContext returns the union data inside the Tool as a UrlContext
func (t Tool) AsUrlContext() (UrlContext, error) {
	var body UrlContext
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUrlContext overwrites any union data inside the Tool as the provided UrlContext
func (t *Tool) FromUrlContext(v UrlContext) error {
	v.Type = "url_context"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUrlContext performs a merge with any union data inside the Tool, using the provided UrlContext
func (t *Tool) MergeUrlContext(v UrlContext) error {
	v.Type = "url_context"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsComputerUse returns the union data inside the Tool as a ComputerUse
func (t Tool) AsComputerUse() (ComputerUse, error) {
	var body ComputerUse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromComputerUse overwrites any union data inside the Tool as the provided ComputerUse
func (t *Tool) FromComputerUse(v ComputerUse) error {
	v.Type = "computer_use"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeComputerUse performs a merge with any union data inside the Tool, using the provided ComputerUse
func (t *Tool) MergeComputerUse(v ComputerUse) error {
	v.Type = "computer_use"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMcpServer returns the union data inside the Tool as a McpServer
func (t Tool) AsMcpServer() (McpServer, error) {
	var body McpServer
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMcpServer overwrites any union data inside the Tool as the provided McpServer
func (t *Tool) FromMcpServer(v McpServer) error {
	v.Type = "mcp_server"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMcpServer performs a merge with any union data inside the Tool, using the provided McpServer
func (t *Tool) MergeMcpServer(v McpServer) error {
	v.Type = "mcp_server"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFileSearch returns the union data inside the Tool as a FileSearch
func (t Tool) AsFileSearch() (FileSearch, error) {
	var body FileSearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFileSearch overwrites any union data inside the Tool as the provided FileSearch
func (t *Tool) FromFileSearch(v FileSearch) error {
	v.Type = "file_search"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFileSearch performs a merge with any union data inside the Tool, using the provided FileSearch
func (t *Tool) MergeFileSearch(v FileSearch) error {
	v.Type = "file_search"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Tool) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Tool) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "code_execution":
		return t.AsCodeExecution()
	case "computer_use":
		return t.AsComputerUse()
	case "file_search":
		return t.AsFileSearch()
	case "function":
		return t.AsFunction()
	case "google_search":
		return t.AsGoogleSearch()
	case "mcp_server":
		return t.AsMcpServer()
	case "url_context":
		return t.AsUrlContext()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Tool) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Tool) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsToolChoiceType returns the union data inside the ToolChoice as a ToolChoiceType
func (t ToolChoice) AsToolChoiceType() (ToolChoiceType, error) {
	var body ToolChoiceType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromToolChoiceType overwrites any union data inside the ToolChoice as the provided ToolChoiceType
func (t *ToolChoice) FromToolChoiceType(v ToolChoiceType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeToolChoiceType performs a merge with any union data inside the ToolChoice, using the provided ToolChoiceType
func (t *ToolChoice) MergeToolChoiceType(v ToolChoiceType) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsToolChoiceConfig returns the union data inside the ToolChoice as a ToolChoiceConfig
func (t ToolChoice) AsToolChoiceConfig() (ToolChoiceConfig, error) {
	var body ToolChoiceConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromToolChoiceConfig overwrites any union data inside the ToolChoice as the provided ToolChoiceConfig
func (t *ToolChoice) FromToolChoiceConfig(v ToolChoiceConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeToolChoiceConfig performs a merge with any union data inside the ToolChoice, using the provided ToolChoiceConfig
func (t *ToolChoice) MergeToolChoiceConfig(v ToolChoiceConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ToolChoice) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ToolChoice) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTurnContent0 returns the union data inside the Turn_Content as a TurnContent0
func (t Turn_Content) AsTurnContent0() (TurnContent0, error) {
	var body TurnContent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTurnContent0 overwrites any union data inside the Turn_Content as the provided TurnContent0
func (t *Turn_Content) FromTurnContent0(v TurnContent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTurnContent0 performs a merge with any union data inside the Turn_Content, using the provided TurnContent0
func (t *Turn_Content) MergeTurnContent0(v TurnContent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTurnContent1 returns the union data inside the Turn_Content as a TurnContent1
func (t Turn_Content) AsTurnContent1() (TurnContent1, error) {
	var body TurnContent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTurnContent1 overwrites any union data inside the Turn_Content as the provided TurnContent1
func (t *Turn_Content) FromTurnContent1(v TurnContent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTurnContent1 performs a merge with any union data inside the Turn_Content, using the provided TurnContent1
func (t *Turn_Content) MergeTurnContent1(v TurnContent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Turn_Content) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Turn_Content) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVideoMimeTypeOption0 returns the union data inside the VideoMimeTypeOption as a VideoMimeTypeOption0
func (t VideoMimeTypeOption) AsVideoMimeTypeOption0() (VideoMimeTypeOption0, error) {
	var body VideoMimeTypeOption0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVideoMimeTypeOption0 overwrites any union data inside the VideoMimeTypeOption as the provided VideoMimeTypeOption0
func (t *VideoMimeTypeOption) FromVideoMimeTypeOption0(v VideoMimeTypeOption0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVideoMimeTypeOption0 performs a merge with any union data inside the VideoMimeTypeOption, using the provided VideoMimeTypeOption0
func (t *VideoMimeTypeOption) MergeVideoMimeTypeOption0(v VideoMimeTypeOption0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVideoMimeTypeOption1 returns the union data inside the VideoMimeTypeOption as a VideoMimeTypeOption1
func (t VideoMimeTypeOption) AsVideoMimeTypeOption1() (VideoMimeTypeOption1, error) {
	var body VideoMimeTypeOption1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVideoMimeTypeOption1 overwrites any union data inside the VideoMimeTypeOption as the provided VideoMimeTypeOption1
func (t *VideoMimeTypeOption) FromVideoMimeTypeOption1(v VideoMimeTypeOption1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVideoMimeTypeOption1 performs a merge with any union data inside the VideoMimeTypeOption, using the provided VideoMimeTypeOption1
func (t *VideoMimeTypeOption) MergeVideoMimeTypeOption1(v VideoMimeTypeOption1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVideoMimeTypeOption2 returns the union data inside the VideoMimeTypeOption as a VideoMimeTypeOption2
func (t VideoMimeTypeOption) AsVideoMimeTypeOption2() (VideoMimeTypeOption2, error) {
	var body VideoMimeTypeOption2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVideoMimeTypeOption2 overwrites any union data inside the VideoMimeTypeOption as the provided VideoMimeTypeOption2
func (t *VideoMimeTypeOption) FromVideoMimeTypeOption2(v VideoMimeTypeOption2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVideoMimeTypeOption2 performs a merge with any union data inside the VideoMimeTypeOption, using the provided VideoMimeTypeOption2
func (t *VideoMimeTypeOption) MergeVideoMimeTypeOption2(v VideoMimeTypeOption2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVideoMimeTypeOption3 returns the union data inside the VideoMimeTypeOption as a VideoMimeTypeOption3
func (t VideoMimeTypeOption) AsVideoMimeTypeOption3() (VideoMimeTypeOption3, error) {
	var body VideoMimeTypeOption3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVideoMimeTypeOption3 overwrites any union data inside the VideoMimeTypeOption as the provided VideoMimeTypeOption3
func (t *VideoMimeTypeOption) FromVideoMimeTypeOption3(v VideoMimeTypeOption3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVideoMimeTypeOption3 performs a merge with any union data inside the VideoMimeTypeOption, using the provided VideoMimeTypeOption3
func (t *VideoMimeTypeOption) MergeVideoMimeTypeOption3(v VideoMimeTypeOption3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVideoMimeTypeOption4 returns the union data inside the VideoMimeTypeOption as a VideoMimeTypeOption4
func (t VideoMimeTypeOption) AsVideoMimeTypeOption4() (VideoMimeTypeOption4, error) {
	var body VideoMimeTypeOption4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVideoMimeTypeOption4 overwrites any union data inside the VideoMimeTypeOption as the provided VideoMimeTypeOption4
func (t *VideoMimeTypeOption) FromVideoMimeTypeOption4(v VideoMimeTypeOption4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVideoMimeTypeOption4 performs a merge with any union data inside the VideoMimeTypeOption, using the provided VideoMimeTypeOption4
func (t *VideoMimeTypeOption) MergeVideoMimeTypeOption4(v VideoMimeTypeOption4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVideoMimeTypeOption5 returns the union data inside the VideoMimeTypeOption as a VideoMimeTypeOption5
func (t VideoMimeTypeOption) AsVideoMimeTypeOption5() (VideoMimeTypeOption5, error) {
	var body VideoMimeTypeOption5
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVideoMimeTypeOption5 overwrites any union data inside the VideoMimeTypeOption as the provided VideoMimeTypeOption5
func (t *VideoMimeTypeOption) FromVideoMimeTypeOption5(v VideoMimeTypeOption5) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVideoMimeTypeOption5 performs a merge with any union data inside the VideoMimeTypeOption, using the provided VideoMimeTypeOption5
func (t *VideoMimeTypeOption) MergeVideoMimeTypeOption5(v VideoMimeTypeOption5) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVideoMimeTypeOption6 returns the union data inside the VideoMimeTypeOption as a VideoMimeTypeOption6
func (t VideoMimeTypeOption) AsVideoMimeTypeOption6() (VideoMimeTypeOption6, error) {
	var body VideoMimeTypeOption6
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVideoMimeTypeOption6 overwrites any union data inside the VideoMimeTypeOption as the provided VideoMimeTypeOption6
func (t *VideoMimeTypeOption) FromVideoMimeTypeOption6(v VideoMimeTypeOption6) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVideoMimeTypeOption6 performs a merge with any union data inside the VideoMimeTypeOption, using the provided VideoMimeTypeOption6
func (t *VideoMimeTypeOption) MergeVideoMimeTypeOption6(v VideoMimeTypeOption6) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVideoMimeTypeOption7 returns the union data inside the VideoMimeTypeOption as a VideoMimeTypeOption7
func (t VideoMimeTypeOption) AsVideoMimeTypeOption7() (VideoMimeTypeOption7, error) {
	var body VideoMimeTypeOption7
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVideoMimeTypeOption7 overwrites any union data inside the VideoMimeTypeOption as the provided VideoMimeTypeOption7
func (t *VideoMimeTypeOption) FromVideoMimeTypeOption7(v VideoMimeTypeOption7) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVideoMimeTypeOption7 performs a merge with any union data inside the VideoMimeTypeOption, using the provided VideoMimeTypeOption7
func (t *VideoMimeTypeOption) MergeVideoMimeTypeOption7(v VideoMimeTypeOption7) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVideoMimeTypeOption8 returns the union data inside the VideoMimeTypeOption as a VideoMimeTypeOption8
func (t VideoMimeTypeOption) AsVideoMimeTypeOption8() (VideoMimeTypeOption8, error) {
	var body VideoMimeTypeOption8
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVideoMimeTypeOption8 overwrites any union data inside the VideoMimeTypeOption as the provided VideoMimeTypeOption8
func (t *VideoMimeTypeOption) FromVideoMimeTypeOption8(v VideoMimeTypeOption8) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVideoMimeTypeOption8 performs a merge with any union data inside the VideoMimeTypeOption, using the provided VideoMimeTypeOption8
func (t *VideoMimeTypeOption) MergeVideoMimeTypeOption8(v VideoMimeTypeOption8) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVideoMimeTypeOption9 returns the union data inside the VideoMimeTypeOption as a VideoMimeTypeOption9
func (t VideoMimeTypeOption) AsVideoMimeTypeOption9() (VideoMimeTypeOption9, error) {
	var body VideoMimeTypeOption9
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVideoMimeTypeOption9 overwrites any union data inside the VideoMimeTypeOption as the provided VideoMimeTypeOption9
func (t *VideoMimeTypeOption) FromVideoMimeTypeOption9(v VideoMimeTypeOption9) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVideoMimeTypeOption9 performs a merge with any union data inside the VideoMimeTypeOption, using the provided VideoMimeTypeOption9
func (t *VideoMimeTypeOption) MergeVideoMimeTypeOption9(v VideoMimeTypeOption9) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VideoMimeTypeOption) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VideoMimeTypeOption) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// CreateInteractionWithBody request with any body
	CreateInteractionWithBody(ctx context.Context, apiVersion ApiVersion, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateInteraction(ctx context.Context, apiVersion ApiVersion, body CreateInteractionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInteraction request
	DeleteInteraction(ctx context.Context, apiVersion ApiVersion, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInteractionById request
	GetInteractionById(ctx context.Context, apiVersion ApiVersion, id string, params *GetInteractionByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelInteractionById request
	CancelInteractionById(ctx context.Context, apiVersion ApiVersion, id string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) CreateInteractionWithBody(ctx context.Context, apiVersion ApiVersion, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInteractionRequestWithBody(c.Server, apiVersion, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateInteraction(ctx context.Context, apiVersion ApiVersion, body CreateInteractionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInteractionRequest(c.Server, apiVersion, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInteraction(ctx context.Context, apiVersion ApiVersion, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInteractionRequest(c.Server, apiVersion, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInteractionById(ctx context.Context, apiVersion ApiVersion, id string, params *GetInteractionByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInteractionByIdRequest(c.Server, apiVersion, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelInteractionById(ctx context.Context, apiVersion ApiVersion, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelInteractionByIdRequest(c.Server, apiVersion, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCreateInteractionRequest calls the generic CreateInteraction builder with application/json body
func NewCreateInteractionRequest(server string, apiVersion ApiVersion, body CreateInteractionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateInteractionRequestWithBody(server, apiVersion, "application/json", bodyReader)
}

// NewCreateInteractionRequestWithBody generates requests for CreateInteraction with any type of body
func NewCreateInteractionRequestWithBody(server string, apiVersion ApiVersion, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "api_version", runtime.ParamLocationPath, apiVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/interactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteInteractionRequest generates requests for DeleteInteraction
func NewDeleteInteractionRequest(server string, apiVersion ApiVersion, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "api_version", runtime.ParamLocationPath, apiVersion)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/interactions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInteractionByIdRequest generates requests for GetInteractionById
func NewGetInteractionByIdRequest(server string, apiVersion ApiVersion, id string, params *GetInteractionByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "api_version", runtime.ParamLocationPath, apiVersion)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/interactions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Stream != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stream", runtime.ParamLocationQuery, *params.Stream); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastEventId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_event_id", runtime.ParamLocationQuery, *params.LastEventId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelInteractionByIdRequest generates requests for CancelInteractionById
func NewCancelInteractionByIdRequest(server string, apiVersion ApiVersion, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "api_version", runtime.ParamLocationPath, apiVersion)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/interactions/%s/cancel", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// CreateInteractionWithBodyWithResponse request with any body
	CreateInteractionWithBodyWithResponse(ctx context.Context, apiVersion ApiVersion, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateInteractionResponse, error)

	CreateInteractionWithResponse(ctx context.Context, apiVersion ApiVersion, body CreateInteractionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateInteractionResponse, error)

	// DeleteInteractionWithResponse request
	DeleteInteractionWithResponse(ctx context.Context, apiVersion ApiVersion, id string, reqEditors ...RequestEditorFn) (*DeleteInteractionResponse, error)

	// GetInteractionByIdWithResponse request
	GetInteractionByIdWithResponse(ctx context.Context, apiVersion ApiVersion, id string, params *GetInteractionByIdParams, reqEditors ...RequestEditorFn) (*GetInteractionByIdResponse, error)

	// CancelInteractionByIdWithResponse request
	CancelInteractionByIdWithResponse(ctx context.Context, apiVersion ApiVersion, id string, reqEditors ...RequestEditorFn) (*CancelInteractionByIdResponse, error)
}

type CreateInteractionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Interaction
	JSONDefault  *struct {
		// Error Error message from an interaction.
		Error *Error `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateInteractionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateInteractionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInteractionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSONDefault  *struct {
		// Error Error message from an interaction.
		Error *Error `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteInteractionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInteractionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInteractionByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Interaction
	JSONDefault  *struct {
		// Error Error message from an interaction.
		Error *Error `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetInteractionByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInteractionByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelInteractionByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Interaction
	JSONDefault  *struct {
		// Error Error message from an interaction.
		Error *Error `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CancelInteractionByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelInteractionByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CreateInteractionWithBodyWithResponse request with arbitrary body returning *CreateInteractionResponse
func (c *ClientWithResponses) CreateInteractionWithBodyWithResponse(ctx context.Context, apiVersion ApiVersion, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateInteractionResponse, error) {
	rsp, err := c.CreateInteractionWithBody(ctx, apiVersion, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInteractionResponse(rsp)
}

func (c *ClientWithResponses) CreateInteractionWithResponse(ctx context.Context, apiVersion ApiVersion, body CreateInteractionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateInteractionResponse, error) {
	rsp, err := c.CreateInteraction(ctx, apiVersion, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInteractionResponse(rsp)
}

// DeleteInteractionWithResponse request returning *DeleteInteractionResponse
func (c *ClientWithResponses) DeleteInteractionWithResponse(ctx context.Context, apiVersion ApiVersion, id string, reqEditors ...RequestEditorFn) (*DeleteInteractionResponse, error) {
	rsp, err := c.DeleteInteraction(ctx, apiVersion, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInteractionResponse(rsp)
}

// GetInteractionByIdWithResponse request returning *GetInteractionByIdResponse
func (c *ClientWithResponses) GetInteractionByIdWithResponse(ctx context.Context, apiVersion ApiVersion, id string, params *GetInteractionByIdParams, reqEditors ...RequestEditorFn) (*GetInteractionByIdResponse, error) {
	rsp, err := c.GetInteractionById(ctx, apiVersion, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInteractionByIdResponse(rsp)
}

// CancelInteractionByIdWithResponse request returning *CancelInteractionByIdResponse
func (c *ClientWithResponses) CancelInteractionByIdWithResponse(ctx context.Context, apiVersion ApiVersion, id string, reqEditors ...RequestEditorFn) (*CancelInteractionByIdResponse, error) {
	rsp, err := c.CancelInteractionById(ctx, apiVersion, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelInteractionByIdResponse(rsp)
}

// ParseCreateInteractionResponse parses an HTTP response from a CreateInteractionWithResponse call
func ParseCreateInteractionResponse(rsp *http.Response) (*CreateInteractionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateInteractionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Interaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Error Error message from an interaction.
			Error *Error `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteInteractionResponse parses an HTTP response from a DeleteInteractionWithResponse call
func ParseDeleteInteractionResponse(rsp *http.Response) (*DeleteInteractionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInteractionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Error Error message from an interaction.
			Error *Error `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetInteractionByIdResponse parses an HTTP response from a GetInteractionByIdWithResponse call
func ParseGetInteractionByIdResponse(rsp *http.Response) (*GetInteractionByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInteractionByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Interaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Error Error message from an interaction.
			Error *Error `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCancelInteractionByIdResponse parses an HTTP response from a CancelInteractionByIdWithResponse call
func ParseCancelInteractionByIdResponse(rsp *http.Response) (*CancelInteractionByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelInteractionByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Interaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Error Error message from an interaction.
			Error *Error `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"VcTa7SCG+H8BAAD//wxCzYzsBAEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
